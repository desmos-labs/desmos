// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: desmos/reactions/v1/models.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Reaction contains the data of a single post reaction
type Reaction struct {
	// Id of the subspace inside which the reaction has been put
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post to which the reaction is associated
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Id of the reaction within the post
	ID uint32 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty" yaml:"id"`
	// Value of the reaction.
	Value *types.Any `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty" yaml:"value"`
	// Author of the reaction
	Author string `protobuf:"bytes,5,opt,name=author,proto3" json:"author,omitempty" yaml:"author"`
}

func (m *Reaction) Reset()         { *m = Reaction{} }
func (m *Reaction) String() string { return proto.CompactTextString(m) }
func (*Reaction) ProtoMessage()    {}
func (*Reaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{0}
}
func (m *Reaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reaction.Merge(m, src)
}
func (m *Reaction) XXX_Size() int {
	return m.Size()
}
func (m *Reaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Reaction.DiscardUnknown(m)
}

var xxx_messageInfo_Reaction proto.InternalMessageInfo

func (m *Reaction) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *Reaction) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *Reaction) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Reaction) GetValue() *types.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Reaction) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

// RegisteredReactionValue contains the details of a reaction value that
// references a reaction registered within the subspace
type RegisteredReactionValue struct {
	// Id of the registered reaction
	RegisteredReactionID uint32 `protobuf:"varint,1,opt,name=registered_reaction_id,json=registeredReactionId,proto3" json:"registered_reaction_id,omitempty" yaml:"registered_reaction_id"`
}

func (m *RegisteredReactionValue) Reset()         { *m = RegisteredReactionValue{} }
func (m *RegisteredReactionValue) String() string { return proto.CompactTextString(m) }
func (*RegisteredReactionValue) ProtoMessage()    {}
func (*RegisteredReactionValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{1}
}
func (m *RegisteredReactionValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisteredReactionValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisteredReactionValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisteredReactionValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisteredReactionValue.Merge(m, src)
}
func (m *RegisteredReactionValue) XXX_Size() int {
	return m.Size()
}
func (m *RegisteredReactionValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisteredReactionValue.DiscardUnknown(m)
}

var xxx_messageInfo_RegisteredReactionValue proto.InternalMessageInfo

func (m *RegisteredReactionValue) GetRegisteredReactionID() uint32 {
	if m != nil {
		return m.RegisteredReactionID
	}
	return 0
}

// FreeTextValue contains the details of a reaction value that
// is made of free text
type FreeTextValue struct {
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty" yaml:"text"`
}

func (m *FreeTextValue) Reset()         { *m = FreeTextValue{} }
func (m *FreeTextValue) String() string { return proto.CompactTextString(m) }
func (*FreeTextValue) ProtoMessage()    {}
func (*FreeTextValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{2}
}
func (m *FreeTextValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FreeTextValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FreeTextValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FreeTextValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FreeTextValue.Merge(m, src)
}
func (m *FreeTextValue) XXX_Size() int {
	return m.Size()
}
func (m *FreeTextValue) XXX_DiscardUnknown() {
	xxx_messageInfo_FreeTextValue.DiscardUnknown(m)
}

var xxx_messageInfo_FreeTextValue proto.InternalMessageInfo

func (m *FreeTextValue) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// RegisteredReaction contains the details of a registered reaction within a
// subspace
type RegisteredReaction struct {
	// Id of the subspace for which this reaction has been registered
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the registered reaction
	ID uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty" yaml:"id"`
	// Unique shorthand code associated to this reaction
	ShorthandCode string `protobuf:"bytes,3,opt,name=shorthand_code,json=shorthandCode,proto3" json:"shorthand_code,omitempty" yaml:"shorthand_code"`
	// Value that should be displayed when using this reaction
	DisplayValue string `protobuf:"bytes,4,opt,name=display_value,json=displayValue,proto3" json:"display_value,omitempty" yaml:"display_value"`
}

func (m *RegisteredReaction) Reset()         { *m = RegisteredReaction{} }
func (m *RegisteredReaction) String() string { return proto.CompactTextString(m) }
func (*RegisteredReaction) ProtoMessage()    {}
func (*RegisteredReaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{3}
}
func (m *RegisteredReaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisteredReaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisteredReaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisteredReaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisteredReaction.Merge(m, src)
}
func (m *RegisteredReaction) XXX_Size() int {
	return m.Size()
}
func (m *RegisteredReaction) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisteredReaction.DiscardUnknown(m)
}

var xxx_messageInfo_RegisteredReaction proto.InternalMessageInfo

func (m *RegisteredReaction) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *RegisteredReaction) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RegisteredReaction) GetShorthandCode() string {
	if m != nil {
		return m.ShorthandCode
	}
	return ""
}

func (m *RegisteredReaction) GetDisplayValue() string {
	if m != nil {
		return m.DisplayValue
	}
	return ""
}

// SubspaceReactionsParams contains the params related to a single subspace
// reactions
type SubspaceReactionsParams struct {
	// Id of the subspace for which these params are valid
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Params related to RegisteredReactionValue reactions
	RegisteredReaction RegisteredReactionValueParams `protobuf:"bytes,2,opt,name=registered_reaction,json=registeredReaction,proto3" json:"registered_reaction" yaml:"registered_reaction"`
	// Params related to FreeTextValue reactions
	FreeText FreeTextValueParams `protobuf:"bytes,3,opt,name=free_text,json=freeText,proto3" json:"free_text" yaml:"free_text"`
}

func (m *SubspaceReactionsParams) Reset()         { *m = SubspaceReactionsParams{} }
func (m *SubspaceReactionsParams) String() string { return proto.CompactTextString(m) }
func (*SubspaceReactionsParams) ProtoMessage()    {}
func (*SubspaceReactionsParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{4}
}
func (m *SubspaceReactionsParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubspaceReactionsParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubspaceReactionsParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubspaceReactionsParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubspaceReactionsParams.Merge(m, src)
}
func (m *SubspaceReactionsParams) XXX_Size() int {
	return m.Size()
}
func (m *SubspaceReactionsParams) XXX_DiscardUnknown() {
	xxx_messageInfo_SubspaceReactionsParams.DiscardUnknown(m)
}

var xxx_messageInfo_SubspaceReactionsParams proto.InternalMessageInfo

func (m *SubspaceReactionsParams) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *SubspaceReactionsParams) GetRegisteredReaction() RegisteredReactionValueParams {
	if m != nil {
		return m.RegisteredReaction
	}
	return RegisteredReactionValueParams{}
}

func (m *SubspaceReactionsParams) GetFreeText() FreeTextValueParams {
	if m != nil {
		return m.FreeText
	}
	return FreeTextValueParams{}
}

// FreeTextValueParams contains the params for FreeTextValue based reactions
type FreeTextValueParams struct {
	// Whether FreeTextValue reactions should be enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" yaml:"enabled"`
	// The max length that FreeTextValue reactions should have
	MaxLength uint32 `protobuf:"varint,2,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty" yaml:"max_length"`
	// RegEx that each FreeTextValue should respect.
	// This is useful to limit what characters can be used as a reaction.
	RegEx string `protobuf:"bytes,3,opt,name=reg_ex,json=regEx,proto3" json:"reg_ex,omitempty" yaml:"reg_ex"`
}

func (m *FreeTextValueParams) Reset()         { *m = FreeTextValueParams{} }
func (m *FreeTextValueParams) String() string { return proto.CompactTextString(m) }
func (*FreeTextValueParams) ProtoMessage()    {}
func (*FreeTextValueParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{5}
}
func (m *FreeTextValueParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FreeTextValueParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FreeTextValueParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FreeTextValueParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FreeTextValueParams.Merge(m, src)
}
func (m *FreeTextValueParams) XXX_Size() int {
	return m.Size()
}
func (m *FreeTextValueParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FreeTextValueParams.DiscardUnknown(m)
}

var xxx_messageInfo_FreeTextValueParams proto.InternalMessageInfo

func (m *FreeTextValueParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *FreeTextValueParams) GetMaxLength() uint32 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *FreeTextValueParams) GetRegEx() string {
	if m != nil {
		return m.RegEx
	}
	return ""
}

// RegisteredReactionValueParams contains the params for RegisteredReactionValue
// based reactions
type RegisteredReactionValueParams struct {
	// Whether RegisteredReactionValue reactions should be enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" yaml:"enabled"`
}

func (m *RegisteredReactionValueParams) Reset()         { *m = RegisteredReactionValueParams{} }
func (m *RegisteredReactionValueParams) String() string { return proto.CompactTextString(m) }
func (*RegisteredReactionValueParams) ProtoMessage()    {}
func (*RegisteredReactionValueParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88c682704b8a018, []int{6}
}
func (m *RegisteredReactionValueParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisteredReactionValueParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisteredReactionValueParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisteredReactionValueParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisteredReactionValueParams.Merge(m, src)
}
func (m *RegisteredReactionValueParams) XXX_Size() int {
	return m.Size()
}
func (m *RegisteredReactionValueParams) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisteredReactionValueParams.DiscardUnknown(m)
}

var xxx_messageInfo_RegisteredReactionValueParams proto.InternalMessageInfo

func (m *RegisteredReactionValueParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func init() {
	proto.RegisterType((*Reaction)(nil), "desmos.reactions.v1.Reaction")
	proto.RegisterType((*RegisteredReactionValue)(nil), "desmos.reactions.v1.RegisteredReactionValue")
	proto.RegisterType((*FreeTextValue)(nil), "desmos.reactions.v1.FreeTextValue")
	proto.RegisterType((*RegisteredReaction)(nil), "desmos.reactions.v1.RegisteredReaction")
	proto.RegisterType((*SubspaceReactionsParams)(nil), "desmos.reactions.v1.SubspaceReactionsParams")
	proto.RegisterType((*FreeTextValueParams)(nil), "desmos.reactions.v1.FreeTextValueParams")
	proto.RegisterType((*RegisteredReactionValueParams)(nil), "desmos.reactions.v1.RegisteredReactionValueParams")
}

func init() { proto.RegisterFile("desmos/reactions/v1/models.proto", fileDescriptor_b88c682704b8a018) }

var fileDescriptor_b88c682704b8a018 = []byte{
	// 784 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0x8e, 0xbd, 0x6d, 0x36, 0x99, 0x6c, 0x16, 0x3a, 0xc9, 0xb2, 0xd9, 0x8a, 0xc6, 0x61, 0x16,
	0x89, 0x80, 0x88, 0xad, 0x0d, 0x2c, 0x12, 0x95, 0x90, 0xa8, 0x61, 0x91, 0x2a, 0xf5, 0x50, 0xb9,
	0x08, 0x24, 0x2e, 0xd6, 0x24, 0x33, 0x75, 0x2c, 0xd9, 0x9e, 0xc8, 0xe3, 0x44, 0xc9, 0xdf, 0x00,
	0x07, 0x8e, 0x1c, 0x7b, 0xe4, 0x82, 0xc4, 0xa1, 0x17, 0xfe, 0x83, 0x8a, 0x53, 0xc5, 0x89, 0x0b,
	0x06, 0xa5, 0x07, 0x38, 0xfb, 0x2f, 0x40, 0x99, 0x19, 0xe7, 0x87, 0x12, 0x2a, 0x2a, 0xf5, 0x12,
	0xcd, 0xbc, 0xf7, 0xbd, 0xf7, 0xbe, 0xf7, 0xf9, 0xd3, 0x04, 0xb4, 0x08, 0xe5, 0x21, 0xe3, 0x56,
	0x4c, 0x71, 0x3f, 0xf1, 0x59, 0xc4, 0xad, 0xf1, 0x0b, 0x2b, 0x64, 0x84, 0x06, 0xdc, 0x1c, 0xc6,
	0x2c, 0x61, 0xb0, 0x26, 0x11, 0xe6, 0x02, 0x61, 0x8e, 0x5f, 0xec, 0xef, 0xe1, 0xd0, 0x8f, 0x98,
	0x25, 0x7e, 0x25, 0x6e, 0xbf, 0xee, 0x31, 0x8f, 0x89, 0xa3, 0x35, 0x3f, 0xa9, 0xe8, 0x33, 0x8f,
	0x31, 0x2f, 0xa0, 0x96, 0xb8, 0xf5, 0x46, 0xe7, 0x16, 0x8e, 0xa6, 0x79, 0xaa, 0xcf, 0xe6, 0x8d,
	0x5d, 0x59, 0x23, 0x2f, 0x32, 0x85, 0xfe, 0xd0, 0x41, 0xc9, 0x51, 0xf3, 0xe0, 0x2b, 0x50, 0xe1,
	0xa3, 0x1e, 0x1f, 0xe2, 0x3e, 0x75, 0x7d, 0xd2, 0xd0, 0x5a, 0x5a, 0x7b, 0xc7, 0x7e, 0x7b, 0x96,
	0x1a, 0xe0, 0x4c, 0x85, 0x8f, 0x3f, 0xcf, 0x52, 0x03, 0x4e, 0x71, 0x18, 0x1c, 0xa2, 0x15, 0x28,
	0x72, 0x40, 0x7e, 0x3b, 0x26, 0xf0, 0x25, 0x78, 0x38, 0x64, 0x3c, 0x99, 0xb7, 0xd0, 0x45, 0x8b,
	0x37, 0x67, 0xa9, 0x51, 0x3c, 0x65, 0x3c, 0x11, 0xe5, 0x8f, 0x65, 0xb9, 0x82, 0x20, 0xa7, 0x38,
	0x3f, 0x1d, 0x13, 0xf8, 0x1c, 0xe8, 0x3e, 0x69, 0x3c, 0x68, 0x69, 0xed, 0xaa, 0x5d, 0x9b, 0xa5,
	0x86, 0x2e, 0xd0, 0x65, 0x89, 0x9e, 0x03, 0x75, 0x9f, 0x40, 0x0c, 0x76, 0xc7, 0x38, 0x18, 0xd1,
	0xc6, 0x4e, 0x4b, 0x6b, 0x57, 0xba, 0x75, 0x53, 0x6e, 0x6d, 0xe6, 0x5b, 0x9b, 0x47, 0xd1, 0xd4,
	0x7e, 0x99, 0xa5, 0xc6, 0x23, 0x59, 0x27, 0xc0, 0xe8, 0xd7, 0xcb, 0xce, 0x5b, 0x5b, 0xc4, 0x35,
	0xf3, 0xcd, 0xbf, 0x9a, 0xa3, 0x1c, 0xd9, 0x19, 0x1e, 0x81, 0x22, 0x1e, 0x25, 0x03, 0x16, 0x37,
	0x76, 0x5b, 0x5a, 0xbb, 0x6c, 0xbf, 0x9b, 0xa5, 0x46, 0x55, 0x76, 0x93, 0x71, 0xf4, 0xdb, 0x65,
	0xa7, 0xae, 0x54, 0x3c, 0x22, 0x24, 0xa6, 0x9c, 0x9f, 0x25, 0xb1, 0x1f, 0x79, 0x8e, 0x2a, 0x3c,
	0x2c, 0xfd, 0x70, 0x61, 0x68, 0xff, 0x5c, 0x18, 0x1a, 0xfa, 0x45, 0x03, 0x4f, 0x1d, 0xea, 0xf9,
	0x3c, 0xa1, 0x31, 0x25, 0x6b, 0xf3, 0x20, 0x03, 0x6f, 0xc4, 0x8b, 0x94, 0x9b, 0x13, 0xcb, 0x95,
	0xaf, 0xda, 0x1f, 0xcf, 0x52, 0xa3, 0xbe, 0x59, 0x2c, 0x64, 0x39, 0x90, 0x84, 0xb6, 0xd7, 0x23,
	0xa7, 0x1e, 0x6f, 0x96, 0x91, 0xc3, 0x4e, 0x4e, 0xeb, 0x7f, 0xe9, 0x81, 0xfa, 0xa0, 0xfa, 0x45,
	0x4c, 0xe9, 0x97, 0x74, 0x92, 0x48, 0xc2, 0xcf, 0xc1, 0x4e, 0x42, 0x27, 0x89, 0xa0, 0x57, 0xb6,
	0x5f, 0xcb, 0x52, 0xa3, 0x22, 0x69, 0xcc, 0xa3, 0xc8, 0x11, 0xc9, 0xbb, 0x0e, 0xf9, 0x56, 0x07,
	0x70, 0x73, 0xc7, 0xfb, 0xb2, 0xa2, 0xf4, 0x94, 0x7e, 0xbb, 0xa7, 0x3e, 0x05, 0x8f, 0xf9, 0x80,
	0xc5, 0xc9, 0x00, 0x47, 0xc4, 0xed, 0x33, 0x42, 0x85, 0x09, 0xcb, 0xf6, 0xb3, 0x2c, 0x35, 0x9e,
	0xa8, 0x01, 0x6b, 0x79, 0xe4, 0x54, 0x17, 0x81, 0xcf, 0x18, 0xa1, 0xf0, 0x13, 0x50, 0x25, 0x3e,
	0x1f, 0x06, 0x78, 0xea, 0x2e, 0xdd, 0x59, 0xb6, 0x1b, 0x59, 0x6a, 0xd4, 0x65, 0x83, 0xb5, 0x34,
	0x72, 0x1e, 0xa9, 0xbb, 0xd0, 0x60, 0xc5, 0x2e, 0x7f, 0xea, 0xe0, 0x69, 0xbe, 0x60, 0xae, 0x05,
	0x3f, 0xc5, 0x31, 0x0e, 0xf9, 0x7d, 0x49, 0xf2, 0x9d, 0x06, 0x6a, 0x5b, 0x6c, 0x23, 0x44, 0xaa,
	0x74, 0xbb, 0xe6, 0xf6, 0x4f, 0xb6, 0xd5, 0xc1, 0x92, 0x98, 0xfd, 0xce, 0x55, 0x6a, 0x14, 0xb2,
	0xd4, 0xd8, 0xff, 0x4f, 0x4f, 0xa2, 0x1f, 0xff, 0xfe, 0xf9, 0x3d, 0xcd, 0x81, 0x9b, 0xae, 0x84,
	0x04, 0x94, 0xcf, 0x63, 0x4a, 0x5d, 0x61, 0xac, 0x07, 0x82, 0x43, 0x7b, 0x2b, 0x87, 0x35, 0x2b,
	0xaa, 0xc9, 0x07, 0x6a, 0xf2, 0xeb, 0x72, 0xf2, 0xa2, 0x91, 0x9a, 0x57, 0x3a, 0x57, 0x35, 0x2b,
	0x0a, 0xff, 0xa4, 0x81, 0xda, 0x96, 0x56, 0xf0, 0x7d, 0xf0, 0x90, 0x46, 0xb8, 0x17, 0x50, 0xa9,
	0x6c, 0xc9, 0x86, 0xcb, 0xa7, 0x4a, 0x25, 0x90, 0x93, 0x43, 0xe0, 0x87, 0x00, 0x84, 0x78, 0xe2,
	0x06, 0x34, 0xf2, 0x92, 0x81, 0xf2, 0xd7, 0x93, 0x2c, 0x35, 0xf6, 0x64, 0xc1, 0x32, 0x87, 0x9c,
	0x72, 0x88, 0x27, 0x27, 0xe2, 0x0c, 0xdb, 0xa0, 0x18, 0x53, 0xcf, 0xa5, 0x13, 0x65, 0xb0, 0xbd,
	0xe5, 0xcb, 0x22, 0xe3, 0xc8, 0xd9, 0x8d, 0xa9, 0xf7, 0x6a, 0xb2, 0xc2, 0xf7, 0x6b, 0x70, 0x70,
	0xab, 0xfa, 0x77, 0x23, 0xbe, 0x6c, 0x6c, 0x9f, 0x5c, 0xcd, 0x9a, 0xda, 0xf5, 0xac, 0xa9, 0xfd,
	0x35, 0x6b, 0x6a, 0xdf, 0xdf, 0x34, 0x0b, 0xd7, 0x37, 0xcd, 0xc2, 0xef, 0x37, 0xcd, 0xc2, 0x37,
	0x5d, 0xcf, 0x4f, 0x06, 0xa3, 0x9e, 0xd9, 0x67, 0xa1, 0x25, 0xbf, 0x44, 0x27, 0xc0, 0x3d, 0xae,
	0xce, 0xd6, 0xf8, 0x23, 0x6b, 0xb2, 0xf2, 0x2f, 0x96, 0x4c, 0x87, 0x94, 0xf7, 0x8a, 0xe2, 0x01,
	0xfe, 0xe0, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc2, 0x26, 0x52, 0xa6, 0xe6, 0x06, 0x00, 0x00,
}

func (this *Reaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Reaction)
	if !ok {
		that2, ok := that.(Reaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if this.PostID != that1.PostID {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	if this.Author != that1.Author {
		return false
	}
	return true
}
func (this *RegisteredReactionValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegisteredReactionValue)
	if !ok {
		that2, ok := that.(RegisteredReactionValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegisteredReactionID != that1.RegisteredReactionID {
		return false
	}
	return true
}
func (this *FreeTextValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FreeTextValue)
	if !ok {
		that2, ok := that.(FreeTextValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *RegisteredReaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegisteredReaction)
	if !ok {
		that2, ok := that.(RegisteredReaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.ShorthandCode != that1.ShorthandCode {
		return false
	}
	if this.DisplayValue != that1.DisplayValue {
		return false
	}
	return true
}
func (this *SubspaceReactionsParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubspaceReactionsParams)
	if !ok {
		that2, ok := that.(SubspaceReactionsParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if !this.RegisteredReaction.Equal(&that1.RegisteredReaction) {
		return false
	}
	if !this.FreeText.Equal(&that1.FreeText) {
		return false
	}
	return true
}
func (this *FreeTextValueParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FreeTextValueParams)
	if !ok {
		that2, ok := that.(FreeTextValueParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.MaxLength != that1.MaxLength {
		return false
	}
	if this.RegEx != that1.RegEx {
		return false
	}
	return true
}
func (this *RegisteredReactionValueParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegisteredReactionValueParams)
	if !ok {
		that2, ok := that.(RegisteredReactionValueParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (m *Reaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x18
	}
	if m.PostID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisteredReactionValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisteredReactionValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisteredReactionValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegisteredReactionID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.RegisteredReactionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FreeTextValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeTextValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FreeTextValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisteredReaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisteredReaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisteredReaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayValue) > 0 {
		i -= len(m.DisplayValue)
		copy(dAtA[i:], m.DisplayValue)
		i = encodeVarintModels(dAtA, i, uint64(len(m.DisplayValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShorthandCode) > 0 {
		i -= len(m.ShorthandCode)
		copy(dAtA[i:], m.ShorthandCode)
		i = encodeVarintModels(dAtA, i, uint64(len(m.ShorthandCode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubspaceReactionsParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubspaceReactionsParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubspaceReactionsParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FreeText.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintModels(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.RegisteredReaction.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintModels(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FreeTextValueParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeTextValueParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FreeTextValueParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegEx) > 0 {
		i -= len(m.RegEx)
		copy(dAtA[i:], m.RegEx)
		i = encodeVarintModels(dAtA, i, uint64(len(m.RegEx)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxLength != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.MaxLength))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisteredReactionValueParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisteredReactionValueParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisteredReactionValueParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Reaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovModels(uint64(m.PostID))
	}
	if m.ID != 0 {
		n += 1 + sovModels(uint64(m.ID))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *RegisteredReactionValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegisteredReactionID != 0 {
		n += 1 + sovModels(uint64(m.RegisteredReactionID))
	}
	return n
}

func (m *FreeTextValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *RegisteredReaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	if m.ID != 0 {
		n += 1 + sovModels(uint64(m.ID))
	}
	l = len(m.ShorthandCode)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.DisplayValue)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *SubspaceReactionsParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	l = m.RegisteredReaction.Size()
	n += 1 + l + sovModels(uint64(l))
	l = m.FreeText.Size()
	n += 1 + l + sovModels(uint64(l))
	return n
}

func (m *FreeTextValueParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.MaxLength != 0 {
		n += 1 + sovModels(uint64(m.MaxLength))
	}
	l = len(m.RegEx)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *RegisteredReactionValueParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Reaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredReactionValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredReactionValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredReactionValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredReactionID", wireType)
			}
			m.RegisteredReactionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisteredReactionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeTextValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeTextValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeTextValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredReaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredReaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredReaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShorthandCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShorthandCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubspaceReactionsParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubspaceReactionsParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubspaceReactionsParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredReaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegisteredReaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeText", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FreeText.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeTextValueParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeTextValueParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeTextValueParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegEx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegEx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredReactionValueParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredReactionValueParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredReactionValueParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
