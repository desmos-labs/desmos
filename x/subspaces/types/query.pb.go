// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: desmos/subspaces/v3/query.proto

package types

import (
	context "context"
	fmt "fmt"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QuerySubspacesRequest is the request type for the Query/Subspaces RPC method
type QuerySubspacesRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QuerySubspacesRequest) Reset()         { *m = QuerySubspacesRequest{} }
func (m *QuerySubspacesRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySubspacesRequest) ProtoMessage()    {}
func (*QuerySubspacesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{0}
}
func (m *QuerySubspacesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubspacesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubspacesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubspacesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubspacesRequest.Merge(m, src)
}
func (m *QuerySubspacesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubspacesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubspacesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubspacesRequest proto.InternalMessageInfo

func (m *QuerySubspacesRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QuerySubspacesResponse is the response type for the Query/Subspaces RPC
// method
type QuerySubspacesResponse struct {
	Subspaces  []Subspace          `protobuf:"bytes,1,rep,name=subspaces,proto3" json:"subspaces"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QuerySubspacesResponse) Reset()         { *m = QuerySubspacesResponse{} }
func (m *QuerySubspacesResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySubspacesResponse) ProtoMessage()    {}
func (*QuerySubspacesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{1}
}
func (m *QuerySubspacesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubspacesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubspacesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubspacesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubspacesResponse.Merge(m, src)
}
func (m *QuerySubspacesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubspacesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubspacesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubspacesResponse proto.InternalMessageInfo

func (m *QuerySubspacesResponse) GetSubspaces() []Subspace {
	if m != nil {
		return m.Subspaces
	}
	return nil
}

func (m *QuerySubspacesResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QuerySubspace is the request type for the Query/Subspace RPC method
type QuerySubspaceRequest struct {
	// Id of the subspace to query
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
}

func (m *QuerySubspaceRequest) Reset()         { *m = QuerySubspaceRequest{} }
func (m *QuerySubspaceRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySubspaceRequest) ProtoMessage()    {}
func (*QuerySubspaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{2}
}
func (m *QuerySubspaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubspaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubspaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubspaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubspaceRequest.Merge(m, src)
}
func (m *QuerySubspaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubspaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubspaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubspaceRequest proto.InternalMessageInfo

// QuerySubspaceResponse is the response type for the Query/Subspace method
type QuerySubspaceResponse struct {
	Subspace Subspace `protobuf:"bytes,1,opt,name=subspace,proto3" json:"subspace"`
}

func (m *QuerySubspaceResponse) Reset()         { *m = QuerySubspaceResponse{} }
func (m *QuerySubspaceResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySubspaceResponse) ProtoMessage()    {}
func (*QuerySubspaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{3}
}
func (m *QuerySubspaceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubspaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubspaceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubspaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubspaceResponse.Merge(m, src)
}
func (m *QuerySubspaceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubspaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubspaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubspaceResponse proto.InternalMessageInfo

func (m *QuerySubspaceResponse) GetSubspace() Subspace {
	if m != nil {
		return m.Subspace
	}
	return Subspace{}
}

// QuerySectionsRequest is the request type for Query/Sections RPC method
type QuerySectionsRequest struct {
	// Id of the subspace to query the sections for
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QuerySectionsRequest) Reset()         { *m = QuerySectionsRequest{} }
func (m *QuerySectionsRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySectionsRequest) ProtoMessage()    {}
func (*QuerySectionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{4}
}
func (m *QuerySectionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySectionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySectionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySectionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySectionsRequest.Merge(m, src)
}
func (m *QuerySectionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySectionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySectionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySectionsRequest proto.InternalMessageInfo

func (m *QuerySectionsRequest) GetSubspaceId() uint64 {
	if m != nil {
		return m.SubspaceId
	}
	return 0
}

func (m *QuerySectionsRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QuerySectionsResponse is the response type for Query/Sections RPC method
type QuerySectionsResponse struct {
	Sections   []Section           `protobuf:"bytes,1,rep,name=sections,proto3" json:"sections"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QuerySectionsResponse) Reset()         { *m = QuerySectionsResponse{} }
func (m *QuerySectionsResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySectionsResponse) ProtoMessage()    {}
func (*QuerySectionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{5}
}
func (m *QuerySectionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySectionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySectionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySectionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySectionsResponse.Merge(m, src)
}
func (m *QuerySectionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySectionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySectionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySectionsResponse proto.InternalMessageInfo

func (m *QuerySectionsResponse) GetSections() []Section {
	if m != nil {
		return m.Sections
	}
	return nil
}

func (m *QuerySectionsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QuerySectionRequest is the request type for Query/Section RPC method
type QuerySectionRequest struct {
	// Id of the subspace inside which to search for
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty"`
	// Id of the searched section
	SectionId uint32 `protobuf:"varint,2,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
}

func (m *QuerySectionRequest) Reset()         { *m = QuerySectionRequest{} }
func (m *QuerySectionRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySectionRequest) ProtoMessage()    {}
func (*QuerySectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{6}
}
func (m *QuerySectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySectionRequest.Merge(m, src)
}
func (m *QuerySectionRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySectionRequest proto.InternalMessageInfo

func (m *QuerySectionRequest) GetSubspaceId() uint64 {
	if m != nil {
		return m.SubspaceId
	}
	return 0
}

func (m *QuerySectionRequest) GetSectionId() uint32 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

// QuerySectionResponse is the response type for Query/Section RPC method
type QuerySectionResponse struct {
	Section Section `protobuf:"bytes,1,opt,name=section,proto3" json:"section"`
}

func (m *QuerySectionResponse) Reset()         { *m = QuerySectionResponse{} }
func (m *QuerySectionResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySectionResponse) ProtoMessage()    {}
func (*QuerySectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{7}
}
func (m *QuerySectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySectionResponse.Merge(m, src)
}
func (m *QuerySectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySectionResponse proto.InternalMessageInfo

func (m *QuerySectionResponse) GetSection() Section {
	if m != nil {
		return m.Section
	}
	return Section{}
}

// QueryUserGroupsRequest is the request type for the Query/UserGroups RPC
// method
type QueryUserGroupsRequest struct {
	// Id of the subspace to query the groups for
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// (optional) Section id to query the groups for
	SectionId uint32 `protobuf:"varint,2,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,3,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryUserGroupsRequest) Reset()         { *m = QueryUserGroupsRequest{} }
func (m *QueryUserGroupsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUserGroupsRequest) ProtoMessage()    {}
func (*QueryUserGroupsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{8}
}
func (m *QueryUserGroupsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserGroupsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserGroupsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserGroupsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserGroupsRequest.Merge(m, src)
}
func (m *QueryUserGroupsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserGroupsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserGroupsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserGroupsRequest proto.InternalMessageInfo

func (m *QueryUserGroupsRequest) GetSubspaceId() uint64 {
	if m != nil {
		return m.SubspaceId
	}
	return 0
}

func (m *QueryUserGroupsRequest) GetSectionId() uint32 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *QueryUserGroupsRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryUserGroupsResponse is the response type for the Query/UserGroups RPC
// method
type QueryUserGroupsResponse struct {
	Groups     []UserGroup         `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryUserGroupsResponse) Reset()         { *m = QueryUserGroupsResponse{} }
func (m *QueryUserGroupsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUserGroupsResponse) ProtoMessage()    {}
func (*QueryUserGroupsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{9}
}
func (m *QueryUserGroupsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserGroupsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserGroupsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserGroupsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserGroupsResponse.Merge(m, src)
}
func (m *QueryUserGroupsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserGroupsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserGroupsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserGroupsResponse proto.InternalMessageInfo

func (m *QueryUserGroupsResponse) GetGroups() []UserGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *QueryUserGroupsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryUserGroupRequest is the request type for the Query/UserGroup RPC method
type QueryUserGroupRequest struct {
	// Id of the subspace that contains the group
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the group to query
	GroupId uint32 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty" yaml:"group_id"`
}

func (m *QueryUserGroupRequest) Reset()         { *m = QueryUserGroupRequest{} }
func (m *QueryUserGroupRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUserGroupRequest) ProtoMessage()    {}
func (*QueryUserGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{10}
}
func (m *QueryUserGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserGroupRequest.Merge(m, src)
}
func (m *QueryUserGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserGroupRequest proto.InternalMessageInfo

func (m *QueryUserGroupRequest) GetSubspaceId() uint64 {
	if m != nil {
		return m.SubspaceId
	}
	return 0
}

func (m *QueryUserGroupRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

// QueryUserGroupResponse is the response type for the Query/UserGroup RPC
// method
type QueryUserGroupResponse struct {
	Group UserGroup `protobuf:"bytes,1,opt,name=group,proto3" json:"group"`
}

func (m *QueryUserGroupResponse) Reset()         { *m = QueryUserGroupResponse{} }
func (m *QueryUserGroupResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUserGroupResponse) ProtoMessage()    {}
func (*QueryUserGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{11}
}
func (m *QueryUserGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserGroupResponse.Merge(m, src)
}
func (m *QueryUserGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserGroupResponse proto.InternalMessageInfo

func (m *QueryUserGroupResponse) GetGroup() UserGroup {
	if m != nil {
		return m.Group
	}
	return UserGroup{}
}

// QueryUserGroupMembersRequest is the request type for the
// Query/UserGroupMembers RPC method
type QueryUserGroupMembersRequest struct {
	// Id of the subspace that contains the group
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the user group to query the members for
	GroupId uint32 `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty" yaml:"group_id"`
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,3,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryUserGroupMembersRequest) Reset()         { *m = QueryUserGroupMembersRequest{} }
func (m *QueryUserGroupMembersRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUserGroupMembersRequest) ProtoMessage()    {}
func (*QueryUserGroupMembersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{12}
}
func (m *QueryUserGroupMembersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserGroupMembersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserGroupMembersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserGroupMembersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserGroupMembersRequest.Merge(m, src)
}
func (m *QueryUserGroupMembersRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserGroupMembersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserGroupMembersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserGroupMembersRequest proto.InternalMessageInfo

func (m *QueryUserGroupMembersRequest) GetSubspaceId() uint64 {
	if m != nil {
		return m.SubspaceId
	}
	return 0
}

func (m *QueryUserGroupMembersRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *QueryUserGroupMembersRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryUserGroupMembersResponse is the response type for the
// Query/UserGroupMembers RPC method
type QueryUserGroupMembersResponse struct {
	Members    []string            `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryUserGroupMembersResponse) Reset()         { *m = QueryUserGroupMembersResponse{} }
func (m *QueryUserGroupMembersResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUserGroupMembersResponse) ProtoMessage()    {}
func (*QueryUserGroupMembersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{13}
}
func (m *QueryUserGroupMembersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserGroupMembersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserGroupMembersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserGroupMembersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserGroupMembersResponse.Merge(m, src)
}
func (m *QueryUserGroupMembersResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserGroupMembersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserGroupMembersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserGroupMembersResponse proto.InternalMessageInfo

func (m *QueryUserGroupMembersResponse) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *QueryUserGroupMembersResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryUserPermissionsRequest is the request type for the Query/UserPermissions
// RPC method
type QueryUserPermissionsRequest struct {
	// Id of the subspace to query the permissions for
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the section to query the permissions for
	SectionId uint32 `protobuf:"varint,2,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty" yaml:"section_id"`
	// Address of the user to query the permissions for
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty" yaml:"user"`
}

func (m *QueryUserPermissionsRequest) Reset()         { *m = QueryUserPermissionsRequest{} }
func (m *QueryUserPermissionsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUserPermissionsRequest) ProtoMessage()    {}
func (*QueryUserPermissionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{14}
}
func (m *QueryUserPermissionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserPermissionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserPermissionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserPermissionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserPermissionsRequest.Merge(m, src)
}
func (m *QueryUserPermissionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserPermissionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserPermissionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserPermissionsRequest proto.InternalMessageInfo

// QueryUserPermissionsRequest is the response type for the
// Query/UserPermissions method
type QueryUserPermissionsResponse struct {
	Permissions []string           `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty" yaml:"permissions"`
	Details     []PermissionDetail `protobuf:"bytes,2,rep,name=details,proto3" json:"details" yaml:"details"`
}

func (m *QueryUserPermissionsResponse) Reset()         { *m = QueryUserPermissionsResponse{} }
func (m *QueryUserPermissionsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUserPermissionsResponse) ProtoMessage()    {}
func (*QueryUserPermissionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{15}
}
func (m *QueryUserPermissionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUserPermissionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUserPermissionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUserPermissionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUserPermissionsResponse.Merge(m, src)
}
func (m *QueryUserPermissionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUserPermissionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUserPermissionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUserPermissionsResponse proto.InternalMessageInfo

func (m *QueryUserPermissionsResponse) GetPermissions() []string {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *QueryUserPermissionsResponse) GetDetails() []PermissionDetail {
	if m != nil {
		return m.Details
	}
	return nil
}

// PermissionDetail contains the details data of a permission
type PermissionDetail struct {
	// Id of the subspace for which this permission is valid
	SubspaceId uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty"`
	// Id of the section for which this permission is valid
	SectionId uint32 `protobuf:"varint,2,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
	// sum is the oneof that specifies whether this represents a user or
	// group permission detail
	//
	// Types that are valid to be assigned to Sum:
	//	*PermissionDetail_User_
	//	*PermissionDetail_Group_
	Sum isPermissionDetail_Sum `protobuf_oneof:"sum"`
}

func (m *PermissionDetail) Reset()         { *m = PermissionDetail{} }
func (m *PermissionDetail) String() string { return proto.CompactTextString(m) }
func (*PermissionDetail) ProtoMessage()    {}
func (*PermissionDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{16}
}
func (m *PermissionDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PermissionDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PermissionDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PermissionDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PermissionDetail.Merge(m, src)
}
func (m *PermissionDetail) XXX_Size() int {
	return m.Size()
}
func (m *PermissionDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_PermissionDetail.DiscardUnknown(m)
}

var xxx_messageInfo_PermissionDetail proto.InternalMessageInfo

type isPermissionDetail_Sum interface {
	isPermissionDetail_Sum()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PermissionDetail_User_ struct {
	User *PermissionDetail_User `protobuf:"bytes,3,opt,name=user,proto3,oneof" json:"user,omitempty"`
}
type PermissionDetail_Group_ struct {
	Group *PermissionDetail_Group `protobuf:"bytes,4,opt,name=group,proto3,oneof" json:"group,omitempty"`
}

func (*PermissionDetail_User_) isPermissionDetail_Sum()  {}
func (*PermissionDetail_Group_) isPermissionDetail_Sum() {}

func (m *PermissionDetail) GetSum() isPermissionDetail_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *PermissionDetail) GetUser() *PermissionDetail_User {
	if x, ok := m.GetSum().(*PermissionDetail_User_); ok {
		return x.User
	}
	return nil
}

func (m *PermissionDetail) GetGroup() *PermissionDetail_Group {
	if x, ok := m.GetSum().(*PermissionDetail_Group_); ok {
		return x.Group
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PermissionDetail) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PermissionDetail_User_)(nil),
		(*PermissionDetail_Group_)(nil),
	}
}

// User is a permission that has been set to a specific user
type PermissionDetail_User struct {
	// User for which the permission was set
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty" yaml:"user"`
	// Permissions set to the user
	Permission []string `protobuf:"bytes,2,rep,name=permission,proto3" json:"permission,omitempty" yaml:"permission"`
}

func (m *PermissionDetail_User) Reset()         { *m = PermissionDetail_User{} }
func (m *PermissionDetail_User) String() string { return proto.CompactTextString(m) }
func (*PermissionDetail_User) ProtoMessage()    {}
func (*PermissionDetail_User) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{16, 0}
}
func (m *PermissionDetail_User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PermissionDetail_User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PermissionDetail_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PermissionDetail_User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PermissionDetail_User.Merge(m, src)
}
func (m *PermissionDetail_User) XXX_Size() int {
	return m.Size()
}
func (m *PermissionDetail_User) XXX_DiscardUnknown() {
	xxx_messageInfo_PermissionDetail_User.DiscardUnknown(m)
}

var xxx_messageInfo_PermissionDetail_User proto.InternalMessageInfo

// Group is a permission that has been set to a user group
type PermissionDetail_Group struct {
	// Unique id of the group
	GroupID uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty" yaml:"group_id"`
	// Permissions set to the group
	Permission []string `protobuf:"bytes,2,rep,name=permission,proto3" json:"permission,omitempty"`
}

func (m *PermissionDetail_Group) Reset()         { *m = PermissionDetail_Group{} }
func (m *PermissionDetail_Group) String() string { return proto.CompactTextString(m) }
func (*PermissionDetail_Group) ProtoMessage()    {}
func (*PermissionDetail_Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca70010567dbc47d, []int{16, 1}
}
func (m *PermissionDetail_Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PermissionDetail_Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PermissionDetail_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PermissionDetail_Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PermissionDetail_Group.Merge(m, src)
}
func (m *PermissionDetail_Group) XXX_Size() int {
	return m.Size()
}
func (m *PermissionDetail_Group) XXX_DiscardUnknown() {
	xxx_messageInfo_PermissionDetail_Group.DiscardUnknown(m)
}

var xxx_messageInfo_PermissionDetail_Group proto.InternalMessageInfo

func init() {
	proto.RegisterType((*QuerySubspacesRequest)(nil), "desmos.subspaces.v3.QuerySubspacesRequest")
	proto.RegisterType((*QuerySubspacesResponse)(nil), "desmos.subspaces.v3.QuerySubspacesResponse")
	proto.RegisterType((*QuerySubspaceRequest)(nil), "desmos.subspaces.v3.QuerySubspaceRequest")
	proto.RegisterType((*QuerySubspaceResponse)(nil), "desmos.subspaces.v3.QuerySubspaceResponse")
	proto.RegisterType((*QuerySectionsRequest)(nil), "desmos.subspaces.v3.QuerySectionsRequest")
	proto.RegisterType((*QuerySectionsResponse)(nil), "desmos.subspaces.v3.QuerySectionsResponse")
	proto.RegisterType((*QuerySectionRequest)(nil), "desmos.subspaces.v3.QuerySectionRequest")
	proto.RegisterType((*QuerySectionResponse)(nil), "desmos.subspaces.v3.QuerySectionResponse")
	proto.RegisterType((*QueryUserGroupsRequest)(nil), "desmos.subspaces.v3.QueryUserGroupsRequest")
	proto.RegisterType((*QueryUserGroupsResponse)(nil), "desmos.subspaces.v3.QueryUserGroupsResponse")
	proto.RegisterType((*QueryUserGroupRequest)(nil), "desmos.subspaces.v3.QueryUserGroupRequest")
	proto.RegisterType((*QueryUserGroupResponse)(nil), "desmos.subspaces.v3.QueryUserGroupResponse")
	proto.RegisterType((*QueryUserGroupMembersRequest)(nil), "desmos.subspaces.v3.QueryUserGroupMembersRequest")
	proto.RegisterType((*QueryUserGroupMembersResponse)(nil), "desmos.subspaces.v3.QueryUserGroupMembersResponse")
	proto.RegisterType((*QueryUserPermissionsRequest)(nil), "desmos.subspaces.v3.QueryUserPermissionsRequest")
	proto.RegisterType((*QueryUserPermissionsResponse)(nil), "desmos.subspaces.v3.QueryUserPermissionsResponse")
	proto.RegisterType((*PermissionDetail)(nil), "desmos.subspaces.v3.PermissionDetail")
	proto.RegisterType((*PermissionDetail_User)(nil), "desmos.subspaces.v3.PermissionDetail.User")
	proto.RegisterType((*PermissionDetail_Group)(nil), "desmos.subspaces.v3.PermissionDetail.Group")
}

func init() { proto.RegisterFile("desmos/subspaces/v3/query.proto", fileDescriptor_ca70010567dbc47d) }

var fileDescriptor_ca70010567dbc47d = []byte{
	// 1114 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x97, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0x3d, 0x89, 0x53, 0xdb, 0xcf, 0x82, 0x94, 0x49, 0x1b, 0x22, 0x93, 0xec, 0x46, 0x8b,
	0x28, 0x69, 0xd2, 0xee, 0x12, 0x3b, 0x15, 0x25, 0xa0, 0x36, 0x35, 0x55, 0x7e, 0x48, 0x80, 0xca,
	0x42, 0xc5, 0x8f, 0x4b, 0xb5, 0x8e, 0x47, 0xc6, 0x92, 0xed, 0x75, 0x3d, 0x76, 0x44, 0x14, 0x45,
	0xa0, 0x9e, 0x38, 0x70, 0x40, 0x42, 0x82, 0x6b, 0x0e, 0x3d, 0x72, 0xe1, 0x86, 0xc4, 0x81, 0x1b,
	0x2a, 0x27, 0x22, 0x71, 0xe1, 0x64, 0xa1, 0x84, 0x03, 0x67, 0xff, 0x05, 0x68, 0x67, 0x67, 0x66,
	0xc7, 0xeb, 0xc5, 0x59, 0xc7, 0x11, 0x37, 0x7b, 0xe6, 0xbd, 0x79, 0x9f, 0xf7, 0x9d, 0xf7, 0x3c,
	0xcf, 0xa0, 0x97, 0x09, 0xad, 0xbb, 0xd4, 0xa2, 0x9d, 0x12, 0x6d, 0x3a, 0xbb, 0x84, 0x5a, 0x7b,
	0x05, 0xeb, 0x71, 0x87, 0xb4, 0xf6, 0xcd, 0x66, 0xcb, 0x6d, 0xbb, 0x78, 0xc6, 0x37, 0x30, 0xa5,
	0x81, 0xb9, 0x57, 0xc8, 0x5d, 0xa9, 0xb8, 0x15, 0x97, 0xed, 0x5b, 0xde, 0x27, 0xdf, 0x34, 0x37,
	0x5f, 0x71, 0xdd, 0x4a, 0x8d, 0x58, 0x4e, 0xb3, 0x6a, 0x39, 0x8d, 0x86, 0xdb, 0x76, 0xda, 0x55,
	0xb7, 0x41, 0xf9, 0xee, 0xf2, 0xae, 0xcb, 0x22, 0x95, 0x1c, 0x4a, 0xfc, 0x08, 0xd6, 0xde, 0x6a,
	0x89, 0xb4, 0x9d, 0x55, 0xab, 0xe9, 0x54, 0xaa, 0x0d, 0x66, 0xcc, 0x6d, 0x17, 0xa3, 0xa8, 0xea,
	0x6e, 0x99, 0xd4, 0xf8, 0x69, 0xc6, 0x23, 0xb8, 0xfa, 0xbe, 0x77, 0xc6, 0x07, 0xc2, 0xc2, 0x26,
	0x8f, 0x3b, 0x84, 0xb6, 0xf1, 0x26, 0x40, 0x70, 0xdc, 0x1c, 0x5a, 0x44, 0x4b, 0xd9, 0xfc, 0x35,
	0xd3, 0x8f, 0x6d, 0x7a, 0xb1, 0x4d, 0x3f, 0x3b, 0x1e, 0xdb, 0x7c, 0xe0, 0x54, 0x08, 0xf7, 0xb5,
	0x15, 0x4f, 0xe3, 0x29, 0x82, 0xd9, 0x70, 0x04, 0xda, 0x74, 0x1b, 0x94, 0xe0, 0x7b, 0x90, 0x91,
	0x60, 0x73, 0x68, 0x71, 0x72, 0x29, 0x9b, 0x5f, 0x30, 0x23, 0x64, 0x32, 0x85, 0x6b, 0x31, 0xf9,
	0xac, 0xab, 0x27, 0xec, 0xc0, 0x0b, 0x6f, 0xf5, 0x51, 0x4e, 0x30, 0xca, 0x57, 0xcf, 0xa4, 0xf4,
	0xe3, 0xf7, 0x61, 0x7e, 0x02, 0x57, 0xfa, 0x28, 0x85, 0x0c, 0xaf, 0x43, 0x56, 0x44, 0x7b, 0x54,
	0x2d, 0x33, 0x1d, 0x92, 0xc5, 0xd9, 0x5e, 0x57, 0xc7, 0xfb, 0x4e, 0xbd, 0xb6, 0x6e, 0x28, 0x9b,
	0x86, 0x0d, 0xe2, 0xdb, 0x4e, 0x79, 0x3d, 0xfd, 0xd5, 0x91, 0x9e, 0xf8, 0xe7, 0x48, 0x4f, 0x18,
	0x1f, 0x87, 0x24, 0x96, 0xf9, 0xdf, 0x85, 0xb4, 0x70, 0xe0, 0x02, 0xc7, 0x4a, 0x5f, 0x3a, 0x19,
	0x5f, 0x08, 0x68, 0xb2, 0xcb, 0x2a, 0x44, 0x40, 0xeb, 0x11, 0xd0, 0x2a, 0x5c, 0xe8, 0x72, 0x27,
	0xce, 0x7d, 0xb9, 0x47, 0x48, 0xe4, 0x26, 0x09, 0x78, 0x6e, 0x77, 0x20, 0x4d, 0xf9, 0x1a, 0xbf,
	0xda, 0xf9, 0xe8, 0xdc, 0x7c, 0x23, 0x99, 0x1a, 0xf7, 0xb9, 0xb8, 0x8b, 0x7d, 0x08, 0x33, 0x2a,
	0x61, 0x6c, 0x89, 0x16, 0x00, 0x38, 0x8c, 0xb7, 0xef, 0x01, 0x3c, 0x67, 0x67, 0xf8, 0xca, 0x4e,
	0xd9, 0xf8, 0xb0, 0x5f, 0x7a, 0x99, 0xf7, 0x5b, 0x90, 0xe2, 0x46, 0xfc, 0x4a, 0xe3, 0xa4, 0x2d,
	0x5c, 0x8c, 0x9f, 0x44, 0xb3, 0x3c, 0xa4, 0xa4, 0xb5, 0xd5, 0x72, 0x3b, 0x4d, 0x3a, 0x6e, 0x21,
	0x9e, 0x91, 0x48, 0xa8, 0x14, 0x26, 0xc7, 0x29, 0x85, 0x17, 0x07, 0xd0, 0xa5, 0x28, 0x97, 0x2a,
	0x6c, 0x85, 0x97, 0x82, 0x16, 0xa9, 0x89, 0x74, 0xe4, 0xaa, 0x70, 0x9f, 0x8b, 0x2b, 0x85, 0x2f,
	0x45, 0xb5, 0xca, 0x48, 0x63, 0x8b, 0x6b, 0x42, 0x9a, 0x51, 0x4a, 0x69, 0x8b, 0x33, 0xbd, 0xae,
	0x3e, 0xed, 0x7b, 0x89, 0x1d, 0xc3, 0x4e, 0xb1, 0x8f, 0xac, 0x6c, 0x66, 0xc3, 0x04, 0x5c, 0xa3,
	0x75, 0x98, 0x62, 0x46, 0xbc, 0x6c, 0xe2, 0x49, 0xe4, 0xbb, 0x18, 0xbf, 0x23, 0x98, 0xef, 0x3f,
	0xf6, 0x5d, 0x52, 0x2f, 0x91, 0x16, 0xfd, 0xbf, 0xf3, 0xbb, 0xb0, 0x6a, 0x7a, 0x82, 0x60, 0xe1,
	0x3f, 0x32, 0xe2, 0x7a, 0xcd, 0x41, 0xaa, 0xee, 0x2f, 0xb1, 0xa2, 0xca, 0xd8, 0xe2, 0xeb, 0xc5,
	0xd5, 0xcb, 0xcf, 0x08, 0x5e, 0x92, 0x10, 0x0f, 0x48, 0xab, 0x5e, 0xa5, 0x54, 0xfd, 0x99, 0x3d,
	0xb7, 0xaa, 0x6b, 0x83, 0x2d, 0x59, 0xbc, 0xda, 0xeb, 0xea, 0x2f, 0x70, 0x3f, 0xb9, 0x67, 0xa8,
	0x9d, 0xfa, 0x32, 0x24, 0x3b, 0x94, 0xb4, 0x98, 0xaa, 0x99, 0xe2, 0x74, 0xaf, 0xab, 0x67, 0x7d,
	0x7b, 0x6f, 0xd5, 0xb0, 0xd9, 0xa6, 0xf2, 0xec, 0xfc, 0xa8, 0x16, 0x45, 0x1f, 0x3d, 0x57, 0xf0,
	0x36, 0x64, 0x9b, 0xc1, 0xb2, 0xaf, 0xa2, 0x8a, 0xaf, 0x6c, 0x1a, 0xb6, 0x6a, 0x8a, 0x3f, 0x82,
	0x54, 0x99, 0xb4, 0x9d, 0x6a, 0x8d, 0xce, 0x4d, 0xb0, 0x86, 0x7e, 0x25, 0xb2, 0x5a, 0x83, 0xa0,
	0xf7, 0x99, 0x75, 0x71, 0xd6, 0x2b, 0xda, 0x5e, 0x57, 0x7f, 0xde, 0x0f, 0xc0, 0xcf, 0x30, 0x6c,
	0x71, 0x9a, 0xf1, 0xeb, 0x24, 0x5c, 0x0e, 0x7b, 0x8d, 0xfb, 0x53, 0x8d, 0x37, 0x14, 0xdd, 0xb2,
	0xf9, 0xe5, 0x58, 0xa8, 0xac, 0xd3, 0xb6, 0x13, 0xbe, 0xa8, 0xf8, 0x6d, 0xd1, 0x9b, 0x49, 0x76,
	0xc4, 0x4a, 0xbc, 0x23, 0x58, 0xd9, 0x6e, 0x8b, 0x26, 0xcd, 0xd5, 0x20, 0xe9, 0x1d, 0x2a, 0xaf,
	0x11, 0x0d, 0xb9, 0x46, 0x7c, 0x0b, 0x20, 0x10, 0x9c, 0x89, 0x9c, 0x51, 0x2b, 0x24, 0xd8, 0x33,
	0x6c, 0xc5, 0x50, 0xde, 0x3e, 0xca, 0xd5, 0x60, 0x8a, 0xc5, 0xc7, 0x6f, 0x28, 0x1d, 0x8c, 0x58,
	0xa5, 0x69, 0x27, 0x5d, 0x3d, 0xc5, 0x36, 0x77, 0xee, 0x0f, 0x6d, 0x66, 0x6d, 0x10, 0x22, 0x3a,
	0x5a, 0xf0, 0xa9, 0x38, 0x05, 0x93, 0xb4, 0x53, 0xcf, 0x1f, 0x03, 0x4c, 0xb1, 0xe2, 0xc3, 0x5f,
	0x23, 0xc8, 0xc8, 0xd1, 0x0f, 0x47, 0xab, 0x1f, 0x39, 0x81, 0xe6, 0x56, 0x62, 0xd9, 0xfa, 0xc5,
	0x6c, 0x5c, 0x7b, 0xf2, 0xc7, 0xdf, 0xdf, 0x4e, 0x2c, 0x62, 0xcd, 0x1a, 0x1c, 0x79, 0xf3, 0xc1,
	0x17, 0xfc, 0x3d, 0x82, 0xb4, 0xf0, 0xc6, 0xd7, 0xcf, 0x8e, 0x20, 0x60, 0x96, 0xe3, 0x98, 0x72,
	0x96, 0x35, 0xc6, 0x62, 0xe2, 0x1b, 0xc3, 0x59, 0xac, 0x03, 0xa5, 0xac, 0x0f, 0xf1, 0x77, 0x1e,
	0x99, 0x18, 0x7f, 0x86, 0x91, 0xf5, 0x0f, 0x7b, 0x43, 0xc9, 0x42, 0x53, 0x99, 0x51, 0x60, 0x64,
	0x37, 0xf1, 0x4a, 0x24, 0x59, 0x1f, 0x8f, 0x25, 0x47, 0xb1, 0x23, 0x04, 0x29, 0x7e, 0x12, 0x5e,
	0x3a, 0x33, 0x98, 0xc0, 0xba, 0x1e, 0xc3, 0x92, 0x53, 0x6d, 0x30, 0xaa, 0x75, 0x7c, 0x7b, 0x04,
	0x2a, 0xeb, 0x20, 0x68, 0xf9, 0x43, 0xfc, 0x14, 0x01, 0x04, 0x73, 0x07, 0x1e, 0x52, 0x39, 0x03,
	0x83, 0x55, 0xee, 0x46, 0x3c, 0x63, 0xce, 0xfa, 0x26, 0x63, 0xbd, 0x85, 0x0b, 0xa3, 0xdc, 0xad,
	0xc5, 0x27, 0x99, 0x1f, 0x10, 0x64, 0xe4, 0x99, 0xc3, 0x7a, 0x21, 0x3c, 0xa0, 0xe4, 0x56, 0x62,
	0xd9, 0x72, 0xc6, 0x4d, 0xc6, 0xb8, 0x81, 0xef, 0x9c, 0x83, 0xd1, 0x3a, 0x10, 0x3f, 0x04, 0x87,
	0xf8, 0x37, 0x04, 0x97, 0xc3, 0xef, 0x2f, 0x5e, 0x8d, 0x41, 0xd2, 0x3f, 0x7d, 0xe4, 0xf2, 0xa3,
	0xb8, 0xf0, 0x1c, 0xde, 0x63, 0x39, 0x6c, 0xe3, 0xcd, 0xf1, 0x72, 0xb0, 0xc4, 0x50, 0xf0, 0x0b,
	0x82, 0xe9, 0xd0, 0x43, 0x88, 0x5f, 0x1b, 0xce, 0x35, 0xf8, 0xe2, 0xe7, 0x56, 0x47, 0xf0, 0xe0,
	0x89, 0x6c, 0xb1, 0x44, 0xee, 0xe1, 0xbb, 0x23, 0x25, 0xa2, 0xbc, 0xb6, 0xd6, 0x81, 0xf7, 0x22,
	0x1c, 0x16, 0xdf, 0x79, 0x76, 0xa2, 0xa1, 0xe3, 0x13, 0x0d, 0xfd, 0x75, 0xa2, 0xa1, 0x6f, 0x4e,
	0xb5, 0xc4, 0xf1, 0xa9, 0x96, 0xf8, 0xf3, 0x54, 0x4b, 0x7c, 0x9a, 0xaf, 0x54, 0xdb, 0x9f, 0x75,
	0x4a, 0xe6, 0xae, 0x5b, 0xe7, 0x41, 0x6e, 0xd6, 0x9c, 0x12, 0x15, 0x01, 0xf7, 0xd6, 0xac, 0xcf,
	0x95, 0x40, 0xed, 0xfd, 0x26, 0xa1, 0xa5, 0x4b, 0xec, 0xef, 0x7f, 0xe1, 0xdf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x8f, 0x27, 0xf8, 0x58, 0xb8, 0x10, 0x00, 0x00,
}

func (this *PermissionDetail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PermissionDetail)
	if !ok {
		that2, ok := that.(PermissionDetail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceId != that1.SubspaceId {
		return false
	}
	if this.SectionId != that1.SectionId {
		return false
	}
	if that1.Sum == nil {
		if this.Sum != nil {
			return false
		}
	} else if this.Sum == nil {
		return false
	} else if !this.Sum.Equal(that1.Sum) {
		return false
	}
	return true
}
func (this *PermissionDetail_User_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PermissionDetail_User_)
	if !ok {
		that2, ok := that.(PermissionDetail_User_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	return true
}
func (this *PermissionDetail_Group_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PermissionDetail_Group_)
	if !ok {
		that2, ok := that.(PermissionDetail_Group_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Group.Equal(that1.Group) {
		return false
	}
	return true
}
func (this *PermissionDetail_User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PermissionDetail_User)
	if !ok {
		that2, ok := that.(PermissionDetail_User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if len(this.Permission) != len(that1.Permission) {
		return false
	}
	for i := range this.Permission {
		if this.Permission[i] != that1.Permission[i] {
			return false
		}
	}
	return true
}
func (this *PermissionDetail_Group) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PermissionDetail_Group)
	if !ok {
		that2, ok := that.(PermissionDetail_Group)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if len(this.Permission) != len(that1.Permission) {
		return false
	}
	for i := range this.Permission {
		if this.Permission[i] != that1.Permission[i] {
			return false
		}
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Subspaces queries all the subspaces inside Desmos
	Subspaces(ctx context.Context, in *QuerySubspacesRequest, opts ...grpc.CallOption) (*QuerySubspacesResponse, error)
	// Subspace queries all the information about the subspace with the given id
	Subspace(ctx context.Context, in *QuerySubspaceRequest, opts ...grpc.CallOption) (*QuerySubspaceResponse, error)
	// Sections allows to query for the sections of a specific subspace
	Sections(ctx context.Context, in *QuerySectionsRequest, opts ...grpc.CallOption) (*QuerySectionsResponse, error)
	// Section queries all the information about the section with the given id
	Section(ctx context.Context, in *QuerySectionRequest, opts ...grpc.CallOption) (*QuerySectionResponse, error)
	// UserGroups queries all the groups that are present inside the subspace with
	// the given id
	UserGroups(ctx context.Context, in *QueryUserGroupsRequest, opts ...grpc.CallOption) (*QueryUserGroupsResponse, error)
	// UserGroup queries the user group having the given id inside the specific
	// subspace
	UserGroup(ctx context.Context, in *QueryUserGroupRequest, opts ...grpc.CallOption) (*QueryUserGroupResponse, error)
	// UserGroupMembers queries all the members of a given user group
	UserGroupMembers(ctx context.Context, in *QueryUserGroupMembersRequest, opts ...grpc.CallOption) (*QueryUserGroupMembersResponse, error)
	// UserPermissions queries the permissions for the given user
	UserPermissions(ctx context.Context, in *QueryUserPermissionsRequest, opts ...grpc.CallOption) (*QueryUserPermissionsResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Subspaces(ctx context.Context, in *QuerySubspacesRequest, opts ...grpc.CallOption) (*QuerySubspacesResponse, error) {
	out := new(QuerySubspacesResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/Subspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Subspace(ctx context.Context, in *QuerySubspaceRequest, opts ...grpc.CallOption) (*QuerySubspaceResponse, error) {
	out := new(QuerySubspaceResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/Subspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Sections(ctx context.Context, in *QuerySectionsRequest, opts ...grpc.CallOption) (*QuerySectionsResponse, error) {
	out := new(QuerySectionsResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/Sections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Section(ctx context.Context, in *QuerySectionRequest, opts ...grpc.CallOption) (*QuerySectionResponse, error) {
	out := new(QuerySectionResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/Section", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UserGroups(ctx context.Context, in *QueryUserGroupsRequest, opts ...grpc.CallOption) (*QueryUserGroupsResponse, error) {
	out := new(QueryUserGroupsResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/UserGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UserGroup(ctx context.Context, in *QueryUserGroupRequest, opts ...grpc.CallOption) (*QueryUserGroupResponse, error) {
	out := new(QueryUserGroupResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/UserGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UserGroupMembers(ctx context.Context, in *QueryUserGroupMembersRequest, opts ...grpc.CallOption) (*QueryUserGroupMembersResponse, error) {
	out := new(QueryUserGroupMembersResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/UserGroupMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UserPermissions(ctx context.Context, in *QueryUserPermissionsRequest, opts ...grpc.CallOption) (*QueryUserPermissionsResponse, error) {
	out := new(QueryUserPermissionsResponse)
	err := c.cc.Invoke(ctx, "/desmos.subspaces.v3.Query/UserPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Subspaces queries all the subspaces inside Desmos
	Subspaces(context.Context, *QuerySubspacesRequest) (*QuerySubspacesResponse, error)
	// Subspace queries all the information about the subspace with the given id
	Subspace(context.Context, *QuerySubspaceRequest) (*QuerySubspaceResponse, error)
	// Sections allows to query for the sections of a specific subspace
	Sections(context.Context, *QuerySectionsRequest) (*QuerySectionsResponse, error)
	// Section queries all the information about the section with the given id
	Section(context.Context, *QuerySectionRequest) (*QuerySectionResponse, error)
	// UserGroups queries all the groups that are present inside the subspace with
	// the given id
	UserGroups(context.Context, *QueryUserGroupsRequest) (*QueryUserGroupsResponse, error)
	// UserGroup queries the user group having the given id inside the specific
	// subspace
	UserGroup(context.Context, *QueryUserGroupRequest) (*QueryUserGroupResponse, error)
	// UserGroupMembers queries all the members of a given user group
	UserGroupMembers(context.Context, *QueryUserGroupMembersRequest) (*QueryUserGroupMembersResponse, error)
	// UserPermissions queries the permissions for the given user
	UserPermissions(context.Context, *QueryUserPermissionsRequest) (*QueryUserPermissionsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Subspaces(ctx context.Context, req *QuerySubspacesRequest) (*QuerySubspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subspaces not implemented")
}
func (*UnimplementedQueryServer) Subspace(ctx context.Context, req *QuerySubspaceRequest) (*QuerySubspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subspace not implemented")
}
func (*UnimplementedQueryServer) Sections(ctx context.Context, req *QuerySectionsRequest) (*QuerySectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sections not implemented")
}
func (*UnimplementedQueryServer) Section(ctx context.Context, req *QuerySectionRequest) (*QuerySectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Section not implemented")
}
func (*UnimplementedQueryServer) UserGroups(ctx context.Context, req *QueryUserGroupsRequest) (*QueryUserGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGroups not implemented")
}
func (*UnimplementedQueryServer) UserGroup(ctx context.Context, req *QueryUserGroupRequest) (*QueryUserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGroup not implemented")
}
func (*UnimplementedQueryServer) UserGroupMembers(ctx context.Context, req *QueryUserGroupMembersRequest) (*QueryUserGroupMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGroupMembers not implemented")
}
func (*UnimplementedQueryServer) UserPermissions(ctx context.Context, req *QueryUserPermissionsRequest) (*QueryUserPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserPermissions not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Subspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySubspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Subspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/Subspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Subspaces(ctx, req.(*QuerySubspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Subspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySubspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Subspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/Subspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Subspace(ctx, req.(*QuerySubspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Sections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Sections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/Sections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Sections(ctx, req.(*QuerySectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Section_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Section(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/Section",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Section(ctx, req.(*QuerySectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UserGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UserGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/UserGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UserGroups(ctx, req.(*QueryUserGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UserGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UserGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/UserGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UserGroup(ctx, req.(*QueryUserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UserGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserGroupMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UserGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/UserGroupMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UserGroupMembers(ctx, req.(*QueryUserGroupMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UserPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.subspaces.v3.Query/UserPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UserPermissions(ctx, req.(*QueryUserPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "desmos.subspaces.v3.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subspaces",
			Handler:    _Query_Subspaces_Handler,
		},
		{
			MethodName: "Subspace",
			Handler:    _Query_Subspace_Handler,
		},
		{
			MethodName: "Sections",
			Handler:    _Query_Sections_Handler,
		},
		{
			MethodName: "Section",
			Handler:    _Query_Section_Handler,
		},
		{
			MethodName: "UserGroups",
			Handler:    _Query_UserGroups_Handler,
		},
		{
			MethodName: "UserGroup",
			Handler:    _Query_UserGroup_Handler,
		},
		{
			MethodName: "UserGroupMembers",
			Handler:    _Query_UserGroupMembers_Handler,
		},
		{
			MethodName: "UserPermissions",
			Handler:    _Query_UserPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "desmos/subspaces/v3/query.proto",
}

func (m *QuerySubspacesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubspacesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubspacesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubspacesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubspacesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubspacesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subspaces) > 0 {
		for iNdEx := len(m.Subspaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subspaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubspaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubspaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubspaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubspaceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubspaceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubspaceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Subspace.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySectionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySectionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySectionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySectionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySectionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySectionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sections) > 0 {
		for iNdEx := len(m.Sections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuerySectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySectionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySectionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SectionId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SectionId))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuerySectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Section.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryUserGroupsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserGroupsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserGroupsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SectionId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SectionId))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserGroupsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserGroupsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserGroupsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryUserGroupMembersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserGroupMembersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserGroupMembersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserGroupMembersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserGroupMembersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserGroupMembersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserPermissionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserPermissionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserPermissionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SectionId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SectionId))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryUserPermissionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserPermissionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUserPermissionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Details[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Permissions) > 0 {
		for iNdEx := len(m.Permissions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Permissions[iNdEx])
			copy(dAtA[i:], m.Permissions[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Permissions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PermissionDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermissionDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SectionId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SectionId))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceId != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubspaceId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PermissionDetail_User_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionDetail_User_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PermissionDetail_Group_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionDetail_Group_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PermissionDetail_User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermissionDetail_User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionDetail_User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		for iNdEx := len(m.Permission) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Permission[iNdEx])
			copy(dAtA[i:], m.Permission[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Permission[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PermissionDetail_Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermissionDetail_Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionDetail_Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		for iNdEx := len(m.Permission) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Permission[iNdEx])
			copy(dAtA[i:], m.Permission[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Permission[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GroupID != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QuerySubspacesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySubspacesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subspaces) > 0 {
		for _, e := range m.Subspaces {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySubspaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	return n
}

func (m *QuerySubspaceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Subspace.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QuerySectionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySectionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for _, e := range m.Sections {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySectionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.SectionId != 0 {
		n += 1 + sovQuery(uint64(m.SectionId))
	}
	return n
}

func (m *QuerySectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Section.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryUserGroupsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.SectionId != 0 {
		n += 1 + sovQuery(uint64(m.SectionId))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUserGroupsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUserGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.GroupId != 0 {
		n += 1 + sovQuery(uint64(m.GroupId))
	}
	return n
}

func (m *QueryUserGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Group.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryUserGroupMembersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.GroupId != 0 {
		n += 1 + sovQuery(uint64(m.GroupId))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUserGroupMembersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUserPermissionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.SectionId != 0 {
		n += 1 + sovQuery(uint64(m.SectionId))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUserPermissionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, s := range m.Permissions {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *PermissionDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceId != 0 {
		n += 1 + sovQuery(uint64(m.SubspaceId))
	}
	if m.SectionId != 0 {
		n += 1 + sovQuery(uint64(m.SectionId))
	}
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *PermissionDetail_User_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *PermissionDetail_Group_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *PermissionDetail_User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Permission) > 0 {
		for _, s := range m.Permission {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *PermissionDetail_Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovQuery(uint64(m.GroupID))
	}
	if len(m.Permission) > 0 {
		for _, s := range m.Permission {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QuerySubspacesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubspacesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubspacesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubspacesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubspacesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubspacesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subspaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subspaces = append(m.Subspaces, Subspace{})
			if err := m.Subspaces[len(m.Subspaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubspaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubspaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubspaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubspaceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubspaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubspaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subspace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subspace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySectionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySectionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySectionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySectionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySectionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySectionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sections = append(m.Sections, Section{})
			if err := m.Sections[len(m.Sections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Section", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Section.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserGroupsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserGroupsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserGroupsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserGroupsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserGroupsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserGroupsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, UserGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserGroupMembersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserGroupMembersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserGroupMembersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserGroupMembersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserGroupMembersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserGroupMembersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserPermissionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserPermissionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserPermissionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserPermissionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserPermissionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserPermissionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, PermissionDetail{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermissionDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PermissionDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PermissionDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceId", wireType)
			}
			m.SubspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PermissionDetail_User{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &PermissionDetail_User_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PermissionDetail_Group{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &PermissionDetail_Group_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermissionDetail_User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = append(m.Permission, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PermissionDetail_Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = append(m.Permission, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
