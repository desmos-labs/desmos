// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: desmos/posts/v3/models.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PostReferenceType represents the different types of references
type PostReferenceType int32

const (
	// No reference specified
	POST_REFERENCE_TYPE_UNSPECIFIED PostReferenceType = 0
	// This reference represents a reply to the specified post
	POST_REFERENCE_TYPE_REPLY PostReferenceType = 1
	// This reference represents a quote of the specified post
	POST_REFERENCE_TYPE_QUOTE PostReferenceType = 2
	// This reference represents a repost of the specified post
	POST_REFERENCE_TYPE_REPOST PostReferenceType = 3
)

var PostReferenceType_name = map[int32]string{
	0: "POST_REFERENCE_TYPE_UNSPECIFIED",
	1: "POST_REFERENCE_TYPE_REPLY",
	2: "POST_REFERENCE_TYPE_QUOTE",
	3: "POST_REFERENCE_TYPE_REPOST",
}

var PostReferenceType_value = map[string]int32{
	"POST_REFERENCE_TYPE_UNSPECIFIED": 0,
	"POST_REFERENCE_TYPE_REPLY":       1,
	"POST_REFERENCE_TYPE_QUOTE":       2,
	"POST_REFERENCE_TYPE_REPOST":      3,
}

func (x PostReferenceType) String() string {
	return proto.EnumName(PostReferenceType_name, int32(x))
}

func (PostReferenceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{0}
}

// ReplySetting contains the possible reply settings that a post can have
type ReplySetting int32

const (
	// No reply setting specified
	REPLY_SETTING_UNSPECIFIED ReplySetting = 0
	// Everyone will be able to reply to this post
	REPLY_SETTING_EVERYONE ReplySetting = 1
	// Only followers of the author will be able to reply to this post
	REPLY_SETTING_FOLLOWERS ReplySetting = 2
	// Only the author mutual followers will be able to reply to this post
	REPLY_SETTING_MUTUAL ReplySetting = 3
	// Only people mentioned inside this post will be able to reply
	REPLY_SETTING_MENTIONS ReplySetting = 4
)

var ReplySetting_name = map[int32]string{
	0: "REPLY_SETTING_UNSPECIFIED",
	1: "REPLY_SETTING_EVERYONE",
	2: "REPLY_SETTING_FOLLOWERS",
	3: "REPLY_SETTING_MUTUAL",
	4: "REPLY_SETTING_MENTIONS",
}

var ReplySetting_value = map[string]int32{
	"REPLY_SETTING_UNSPECIFIED": 0,
	"REPLY_SETTING_EVERYONE":    1,
	"REPLY_SETTING_FOLLOWERS":   2,
	"REPLY_SETTING_MUTUAL":      3,
	"REPLY_SETTING_MENTIONS":    4,
}

func (x ReplySetting) String() string {
	return proto.EnumName(ReplySetting_name, int32(x))
}

func (ReplySetting) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{1}
}

// Post contains all the information about a single post
type Post struct {
	// Id of the subspace inside which the post has been created
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the section inside which the post has been created
	SectionID uint32 `protobuf:"varint,2,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty" yaml:"section_id"`
	// Unique id of the post
	ID uint64 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty" yaml:"id"`
	// (optional) External id for this post
	ExternalID string `protobuf:"bytes,4,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty" yaml:"external_id"`
	// (optional) Text of the post
	Text string `protobuf:"bytes,5,opt,name=text,proto3" json:"text,omitempty" yaml:"text"`
	// (optional) Entities connected to this post
	Entities *Entities `protobuf:"bytes,6,opt,name=entities,proto3" json:"entities,omitempty" yaml:"entities"`
	// Tags related to this post, useful for categorization
	Tags []string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" yaml:"tags"`
	// Author of the post
	Author string `protobuf:"bytes,8,opt,name=author,proto3" json:"author,omitempty" yaml:"author"`
	// (optional) Id of the original post of the conversation
	ConversationID uint64 `protobuf:"varint,9,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty" yaml:"conversation_id"`
	// A list this posts references (either as a reply, repost or quote)
	ReferencedPosts []PostReference `protobuf:"bytes,10,rep,name=referenced_posts,json=referencedPosts,proto3" json:"referenced_posts" yaml:"referenced_posts"`
	// Reply settings of this post
	ReplySettings ReplySetting `protobuf:"varint,11,opt,name=reply_settings,json=replySettings,proto3,enum=desmos.posts.v3.ReplySetting" json:"reply_settings,omitempty" yaml:"reply_settings"`
	// Creation date of the post
	CreationDate time.Time `protobuf:"bytes,12,opt,name=creation_date,json=creationDate,proto3,stdtime" json:"creation_date" yaml:"creation_date"`
	// (optional) Last edited time of the post
	LastEditedDate *time.Time `protobuf:"bytes,13,opt,name=last_edited_date,json=lastEditedDate,proto3,stdtime" json:"last_edited_date,omitempty" yaml:"last_edited_date"`
	// Owner of the post
	Owner string `protobuf:"bytes,14,opt,name=owner,proto3" json:"owner,omitempty" yaml:"owner"`
}

func (m *Post) Reset()         { *m = Post{} }
func (m *Post) String() string { return proto.CompactTextString(m) }
func (*Post) ProtoMessage()    {}
func (*Post) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{0}
}
func (m *Post) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Post) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Post.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Post) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Post.Merge(m, src)
}
func (m *Post) XXX_Size() int {
	return m.Size()
}
func (m *Post) XXX_DiscardUnknown() {
	xxx_messageInfo_Post.DiscardUnknown(m)
}

var xxx_messageInfo_Post proto.InternalMessageInfo

func (m *Post) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *Post) GetSectionID() uint32 {
	if m != nil {
		return m.SectionID
	}
	return 0
}

func (m *Post) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Post) GetExternalID() string {
	if m != nil {
		return m.ExternalID
	}
	return ""
}

func (m *Post) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Post) GetEntities() *Entities {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Post) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Post) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Post) GetConversationID() uint64 {
	if m != nil {
		return m.ConversationID
	}
	return 0
}

func (m *Post) GetReferencedPosts() []PostReference {
	if m != nil {
		return m.ReferencedPosts
	}
	return nil
}

func (m *Post) GetReplySettings() ReplySetting {
	if m != nil {
		return m.ReplySettings
	}
	return REPLY_SETTING_UNSPECIFIED
}

func (m *Post) GetCreationDate() time.Time {
	if m != nil {
		return m.CreationDate
	}
	return time.Time{}
}

func (m *Post) GetLastEditedDate() *time.Time {
	if m != nil {
		return m.LastEditedDate
	}
	return nil
}

func (m *Post) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// PostReference contains the details of a post reference
type PostReference struct {
	// Type of reference
	Type PostReferenceType `protobuf:"varint,1,opt,name=type,proto3,enum=desmos.posts.v3.PostReferenceType" json:"type,omitempty" yaml:"type"`
	// Id of the referenced post
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Position of the reference inside the post's text. This should be used only
	// with the type set to TYPE_QUOTE
	Position uint64 `protobuf:"varint,3,opt,name=position,proto3" json:"position,omitempty" yaml:"position"`
}

func (m *PostReference) Reset()         { *m = PostReference{} }
func (m *PostReference) String() string { return proto.CompactTextString(m) }
func (*PostReference) ProtoMessage()    {}
func (*PostReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{1}
}
func (m *PostReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostReference.Merge(m, src)
}
func (m *PostReference) XXX_Size() int {
	return m.Size()
}
func (m *PostReference) XXX_DiscardUnknown() {
	xxx_messageInfo_PostReference.DiscardUnknown(m)
}

var xxx_messageInfo_PostReference proto.InternalMessageInfo

func (m *PostReference) GetType() PostReferenceType {
	if m != nil {
		return m.Type
	}
	return POST_REFERENCE_TYPE_UNSPECIFIED
}

func (m *PostReference) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *PostReference) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

// Contains the details of entities parsed out of the post text
type Entities struct {
	// Hashtags represent inside the post text
	Hashtags []TextTag `protobuf:"bytes,1,rep,name=hashtags,proto3" json:"hashtags" yaml:"hashtags"`
	// Mentions present inside the post text
	Mentions []TextTag `protobuf:"bytes,2,rep,name=mentions,proto3" json:"mentions" yaml:"mentions"`
	// Links present inside the post text
	Urls []Url `protobuf:"bytes,3,rep,name=urls,proto3" json:"urls" yaml:"urls"`
}

func (m *Entities) Reset()         { *m = Entities{} }
func (m *Entities) String() string { return proto.CompactTextString(m) }
func (*Entities) ProtoMessage()    {}
func (*Entities) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{2}
}
func (m *Entities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entities.Merge(m, src)
}
func (m *Entities) XXX_Size() int {
	return m.Size()
}
func (m *Entities) XXX_DiscardUnknown() {
	xxx_messageInfo_Entities.DiscardUnknown(m)
}

var xxx_messageInfo_Entities proto.InternalMessageInfo

func (m *Entities) GetHashtags() []TextTag {
	if m != nil {
		return m.Hashtags
	}
	return nil
}

func (m *Entities) GetMentions() []TextTag {
	if m != nil {
		return m.Mentions
	}
	return nil
}

func (m *Entities) GetUrls() []Url {
	if m != nil {
		return m.Urls
	}
	return nil
}

// TextTag represents a tag within the post text
type TextTag struct {
	// Index of the character inside the text at which the tag starts
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty" yaml:"start"`
	// Index of the character inside the text at which the tag ends
	End uint64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty" yaml:"end"`
	// Tag reference (user address, hashtag value, etc)
	Tag string `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty" yaml:"tag"`
}

func (m *TextTag) Reset()         { *m = TextTag{} }
func (m *TextTag) String() string { return proto.CompactTextString(m) }
func (*TextTag) ProtoMessage()    {}
func (*TextTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{3}
}
func (m *TextTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextTag.Merge(m, src)
}
func (m *TextTag) XXX_Size() int {
	return m.Size()
}
func (m *TextTag) XXX_DiscardUnknown() {
	xxx_messageInfo_TextTag.DiscardUnknown(m)
}

var xxx_messageInfo_TextTag proto.InternalMessageInfo

func (m *TextTag) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TextTag) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *TextTag) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// Url contains the details of a generic URL
type Url struct {
	// Index of the character inside the text at which the URL starts
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty" yaml:"start"`
	// Index of the character inside the text at which the URL ends
	End uint64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty" yaml:"end"`
	// Value of the URL where the user should be redirected to
	Url string `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty" yaml:"url"`
	// (optional) Display value of the URL
	DisplayUrl string `protobuf:"bytes,4,opt,name=display_url,json=displayUrl,proto3" json:"display_url,omitempty" yaml:"display_url"`
}

func (m *Url) Reset()         { *m = Url{} }
func (m *Url) String() string { return proto.CompactTextString(m) }
func (*Url) ProtoMessage()    {}
func (*Url) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{4}
}
func (m *Url) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Url) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Url.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Url) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Url.Merge(m, src)
}
func (m *Url) XXX_Size() int {
	return m.Size()
}
func (m *Url) XXX_DiscardUnknown() {
	xxx_messageInfo_Url.DiscardUnknown(m)
}

var xxx_messageInfo_Url proto.InternalMessageInfo

func (m *Url) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Url) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Url) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Url) GetDisplayUrl() string {
	if m != nil {
		return m.DisplayUrl
	}
	return ""
}

// Attachment contains the data of a single post attachment
type Attachment struct {
	// Id of the subspace inside which the post to which this attachment should be
	// connected is
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post to which this attachment should be connected
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// If of this attachment
	ID uint32 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty" yaml:"id"`
	// Content of the attachment
	Content *types.Any `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty" yaml:"content"`
}

func (m *Attachment) Reset()         { *m = Attachment{} }
func (m *Attachment) String() string { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()    {}
func (*Attachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{5}
}
func (m *Attachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attachment.Merge(m, src)
}
func (m *Attachment) XXX_Size() int {
	return m.Size()
}
func (m *Attachment) XXX_DiscardUnknown() {
	xxx_messageInfo_Attachment.DiscardUnknown(m)
}

var xxx_messageInfo_Attachment proto.InternalMessageInfo

func (m *Attachment) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *Attachment) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *Attachment) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Attachment) GetContent() *types.Any {
	if m != nil {
		return m.Content
	}
	return nil
}

// Media represents a media attachment
type Media struct {
	Uri      string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty" yaml:"uri"`
	MimeType string `protobuf:"bytes,3,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty" yaml:"mime_type"`
}

func (m *Media) Reset()         { *m = Media{} }
func (m *Media) String() string { return proto.CompactTextString(m) }
func (*Media) ProtoMessage()    {}
func (*Media) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{6}
}
func (m *Media) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Media) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Media.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Media) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Media.Merge(m, src)
}
func (m *Media) XXX_Size() int {
	return m.Size()
}
func (m *Media) XXX_DiscardUnknown() {
	xxx_messageInfo_Media.DiscardUnknown(m)
}

var xxx_messageInfo_Media proto.InternalMessageInfo

func (m *Media) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Media) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

// Poll represents a poll attachment
type Poll struct {
	// Question of the poll
	Question string `protobuf:"bytes,1,opt,name=question,proto3" json:"question,omitempty" yaml:"question"`
	// Answers the users can choose from
	ProvidedAnswers []Poll_ProvidedAnswer `protobuf:"bytes,2,rep,name=provided_answers,json=providedAnswers,proto3" json:"provided_answers" yaml:"provided_answers"`
	// Date at which the poll will close
	EndDate time.Time `protobuf:"bytes,3,opt,name=end_date,json=endDate,proto3,stdtime" json:"end_date" yaml:"end_date"`
	// Whether the poll allows multiple choices from the same user or not
	AllowsMultipleAnswers bool `protobuf:"varint,4,opt,name=allows_multiple_answers,json=allowsMultipleAnswers,proto3" json:"allows_multiple_answers,omitempty" yaml:"allows_multiple_answers"`
	// Whether the poll allows to edit an answer or not
	AllowsAnswerEdits bool `protobuf:"varint,5,opt,name=allows_answer_edits,json=allowsAnswerEdits,proto3" json:"allows_answer_edits,omitempty" yaml:"allows_answers_edits"`
	// Final poll results
	FinalTallyResults *PollTallyResults `protobuf:"bytes,6,opt,name=final_tally_results,json=finalTallyResults,proto3" json:"final_tally_results,omitempty" yaml:"final_tally_results"`
}

func (m *Poll) Reset()         { *m = Poll{} }
func (m *Poll) String() string { return proto.CompactTextString(m) }
func (*Poll) ProtoMessage()    {}
func (*Poll) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{7}
}
func (m *Poll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Poll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Poll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Poll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Poll.Merge(m, src)
}
func (m *Poll) XXX_Size() int {
	return m.Size()
}
func (m *Poll) XXX_DiscardUnknown() {
	xxx_messageInfo_Poll.DiscardUnknown(m)
}

var xxx_messageInfo_Poll proto.InternalMessageInfo

func (m *Poll) GetQuestion() string {
	if m != nil {
		return m.Question
	}
	return ""
}

func (m *Poll) GetProvidedAnswers() []Poll_ProvidedAnswer {
	if m != nil {
		return m.ProvidedAnswers
	}
	return nil
}

func (m *Poll) GetEndDate() time.Time {
	if m != nil {
		return m.EndDate
	}
	return time.Time{}
}

func (m *Poll) GetAllowsMultipleAnswers() bool {
	if m != nil {
		return m.AllowsMultipleAnswers
	}
	return false
}

func (m *Poll) GetAllowsAnswerEdits() bool {
	if m != nil {
		return m.AllowsAnswerEdits
	}
	return false
}

func (m *Poll) GetFinalTallyResults() *PollTallyResults {
	if m != nil {
		return m.FinalTallyResults
	}
	return nil
}

// Provided answer contains the details of a possible poll answer
type Poll_ProvidedAnswer struct {
	// (optional) Text of the answer
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty" yaml:"text"`
	// Content of the attachment
	Attachments []*types.Any `protobuf:"bytes,2,rep,name=attachments,proto3" json:"attachments,omitempty" yaml:"attachments"`
}

func (m *Poll_ProvidedAnswer) Reset()         { *m = Poll_ProvidedAnswer{} }
func (m *Poll_ProvidedAnswer) String() string { return proto.CompactTextString(m) }
func (*Poll_ProvidedAnswer) ProtoMessage()    {}
func (*Poll_ProvidedAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{7, 0}
}
func (m *Poll_ProvidedAnswer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Poll_ProvidedAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Poll_ProvidedAnswer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Poll_ProvidedAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Poll_ProvidedAnswer.Merge(m, src)
}
func (m *Poll_ProvidedAnswer) XXX_Size() int {
	return m.Size()
}
func (m *Poll_ProvidedAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_Poll_ProvidedAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_Poll_ProvidedAnswer proto.InternalMessageInfo

func (m *Poll_ProvidedAnswer) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Poll_ProvidedAnswer) GetAttachments() []*types.Any {
	if m != nil {
		return m.Attachments
	}
	return nil
}

// UserAnswer represents a user answer to a poll
type UserAnswer struct {
	// Subspace id inside which the post related to this attachment is located
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post associated to this attachment
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Id of the poll to which this answer is associated
	PollID uint32 `protobuf:"varint,3,opt,name=poll_id,json=pollId,proto3" json:"poll_id,omitempty" yaml:"poll_id"`
	// Indexes of the answers inside the ProvidedAnswers array
	AnswersIndexes []uint32 `protobuf:"varint,4,rep,packed,name=answers_indexes,json=answersIndexes,proto3" json:"answers_indexes,omitempty" yaml:"answers_indexes"`
	// Address of the user answering the poll
	User string `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty" yaml:"user"`
}

func (m *UserAnswer) Reset()         { *m = UserAnswer{} }
func (m *UserAnswer) String() string { return proto.CompactTextString(m) }
func (*UserAnswer) ProtoMessage()    {}
func (*UserAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{8}
}
func (m *UserAnswer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAnswer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAnswer.Merge(m, src)
}
func (m *UserAnswer) XXX_Size() int {
	return m.Size()
}
func (m *UserAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_UserAnswer proto.InternalMessageInfo

func (m *UserAnswer) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *UserAnswer) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *UserAnswer) GetPollID() uint32 {
	if m != nil {
		return m.PollID
	}
	return 0
}

func (m *UserAnswer) GetAnswersIndexes() []uint32 {
	if m != nil {
		return m.AnswersIndexes
	}
	return nil
}

func (m *UserAnswer) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// PollTallyResults contains the tally results for a poll
type PollTallyResults struct {
	Results []PollTallyResults_AnswerResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results" yaml:"results"`
}

func (m *PollTallyResults) Reset()         { *m = PollTallyResults{} }
func (m *PollTallyResults) String() string { return proto.CompactTextString(m) }
func (*PollTallyResults) ProtoMessage()    {}
func (*PollTallyResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{9}
}
func (m *PollTallyResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PollTallyResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PollTallyResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PollTallyResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PollTallyResults.Merge(m, src)
}
func (m *PollTallyResults) XXX_Size() int {
	return m.Size()
}
func (m *PollTallyResults) XXX_DiscardUnknown() {
	xxx_messageInfo_PollTallyResults.DiscardUnknown(m)
}

var xxx_messageInfo_PollTallyResults proto.InternalMessageInfo

func (m *PollTallyResults) GetResults() []PollTallyResults_AnswerResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// AnswerResult contains the result of a single poll provided answer
type PollTallyResults_AnswerResult struct {
	// Index of the answer inside the poll's ProvidedAnswers slice
	AnswerIndex uint32 `protobuf:"varint,1,opt,name=answer_index,json=answerIndex,proto3" json:"answer_index,omitempty" yaml:"answer_index"`
	// Number of votes the answer has received
	Votes uint64 `protobuf:"varint,2,opt,name=votes,proto3" json:"votes,omitempty" yaml:"votes"`
}

func (m *PollTallyResults_AnswerResult) Reset()         { *m = PollTallyResults_AnswerResult{} }
func (m *PollTallyResults_AnswerResult) String() string { return proto.CompactTextString(m) }
func (*PollTallyResults_AnswerResult) ProtoMessage()    {}
func (*PollTallyResults_AnswerResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{9, 0}
}
func (m *PollTallyResults_AnswerResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PollTallyResults_AnswerResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PollTallyResults_AnswerResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PollTallyResults_AnswerResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PollTallyResults_AnswerResult.Merge(m, src)
}
func (m *PollTallyResults_AnswerResult) XXX_Size() int {
	return m.Size()
}
func (m *PollTallyResults_AnswerResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PollTallyResults_AnswerResult.DiscardUnknown(m)
}

var xxx_messageInfo_PollTallyResults_AnswerResult proto.InternalMessageInfo

func (m *PollTallyResults_AnswerResult) GetAnswerIndex() uint32 {
	if m != nil {
		return m.AnswerIndex
	}
	return 0
}

func (m *PollTallyResults_AnswerResult) GetVotes() uint64 {
	if m != nil {
		return m.Votes
	}
	return 0
}

// Params contains the parameters for the posts module
type Params struct {
	// Maximum length of the post text
	MaxTextLength uint32 `protobuf:"varint,1,opt,name=max_text_length,json=maxTextLength,proto3" json:"max_text_length,omitempty" yaml:"max_text_length"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{10}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxTextLength() uint32 {
	if m != nil {
		return m.MaxTextLength
	}
	return 0
}

// PostOwnerTransferRequest represents a request to transfer the ownership of a
// post from the sender to the receiver
type PostOwnerTransferRequest struct {
	// Id of the subspace that holds the post to transfer
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post which will be transferred
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Address of the sender
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	// Address of the receiver
	Receiver string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty" yaml:"receiver"`
}

func (m *PostOwnerTransferRequest) Reset()         { *m = PostOwnerTransferRequest{} }
func (m *PostOwnerTransferRequest) String() string { return proto.CompactTextString(m) }
func (*PostOwnerTransferRequest) ProtoMessage()    {}
func (*PostOwnerTransferRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e330452b10ff3223, []int{11}
}
func (m *PostOwnerTransferRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostOwnerTransferRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostOwnerTransferRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostOwnerTransferRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostOwnerTransferRequest.Merge(m, src)
}
func (m *PostOwnerTransferRequest) XXX_Size() int {
	return m.Size()
}
func (m *PostOwnerTransferRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PostOwnerTransferRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PostOwnerTransferRequest proto.InternalMessageInfo

func (m *PostOwnerTransferRequest) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *PostOwnerTransferRequest) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *PostOwnerTransferRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *PostOwnerTransferRequest) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func init() {
	proto.RegisterEnum("desmos.posts.v3.PostReferenceType", PostReferenceType_name, PostReferenceType_value)
	proto.RegisterEnum("desmos.posts.v3.ReplySetting", ReplySetting_name, ReplySetting_value)
	proto.RegisterType((*Post)(nil), "desmos.posts.v3.Post")
	proto.RegisterType((*PostReference)(nil), "desmos.posts.v3.PostReference")
	proto.RegisterType((*Entities)(nil), "desmos.posts.v3.Entities")
	proto.RegisterType((*TextTag)(nil), "desmos.posts.v3.TextTag")
	proto.RegisterType((*Url)(nil), "desmos.posts.v3.Url")
	proto.RegisterType((*Attachment)(nil), "desmos.posts.v3.Attachment")
	proto.RegisterType((*Media)(nil), "desmos.posts.v3.Media")
	proto.RegisterType((*Poll)(nil), "desmos.posts.v3.Poll")
	proto.RegisterType((*Poll_ProvidedAnswer)(nil), "desmos.posts.v3.Poll.ProvidedAnswer")
	proto.RegisterType((*UserAnswer)(nil), "desmos.posts.v3.UserAnswer")
	proto.RegisterType((*PollTallyResults)(nil), "desmos.posts.v3.PollTallyResults")
	proto.RegisterType((*PollTallyResults_AnswerResult)(nil), "desmos.posts.v3.PollTallyResults.AnswerResult")
	proto.RegisterType((*Params)(nil), "desmos.posts.v3.Params")
	proto.RegisterType((*PostOwnerTransferRequest)(nil), "desmos.posts.v3.PostOwnerTransferRequest")
}

func init() { proto.RegisterFile("desmos/posts/v3/models.proto", fileDescriptor_e330452b10ff3223) }

var fileDescriptor_e330452b10ff3223 = []byte{
	// 1790 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x92, 0xb4, 0x44, 0x8d, 0x44, 0x8a, 0x1a, 0xc9, 0x36, 0x4d, 0x3b, 0x5c, 0x66, 0xe2,
	0xb6, 0xaa, 0x5b, 0x93, 0xa8, 0x8d, 0x36, 0x80, 0x02, 0x14, 0x10, 0xed, 0xb5, 0xc3, 0x42, 0x16,
	0xd5, 0x21, 0xd9, 0xc0, 0xb9, 0x2c, 0x56, 0xdc, 0x11, 0xb5, 0xc0, 0x72, 0x97, 0xd9, 0x19, 0xca,
	0x22, 0x50, 0xa0, 0xed, 0xad, 0x68, 0x51, 0x20, 0xb7, 0xf6, 0xd0, 0x43, 0x90, 0x5e, 0x7a, 0x2a,
	0x72, 0xf0, 0x1f, 0x11, 0xe4, 0x14, 0xe4, 0xd4, 0xd3, 0xb6, 0xa0, 0x0f, 0xe9, 0x99, 0x7f, 0x41,
	0x31, 0x5f, 0xe4, 0x92, 0xfa, 0x70, 0x12, 0x04, 0xf0, 0x85, 0xe0, 0xbc, 0xf7, 0x7e, 0xef, 0xcd,
	0xbc, 0xef, 0x05, 0x77, 0x5c, 0x42, 0xfb, 0x21, 0xad, 0x0d, 0x42, 0xca, 0x68, 0xed, 0xf4, 0x61,
	0xad, 0x1f, 0xba, 0xc4, 0xa7, 0xd5, 0x41, 0x14, 0xb2, 0x10, 0x6e, 0x48, 0x6e, 0x55, 0x70, 0xab,
	0xa7, 0x0f, 0x4b, 0x9b, 0x4e, 0xdf, 0x0b, 0xc2, 0x9a, 0xf8, 0x95, 0x32, 0xa5, 0xed, 0x5e, 0xd8,
	0x0b, 0xc5, 0xdf, 0x1a, 0xff, 0xa7, 0xa8, 0xb7, 0x7a, 0x61, 0xd8, 0xf3, 0x49, 0x4d, 0x9c, 0x8e,
	0x86, 0xc7, 0x35, 0x27, 0x18, 0x29, 0x96, 0xb9, 0xc8, 0x62, 0x5e, 0x9f, 0x50, 0xe6, 0xf4, 0x07,
	0x1a, 0xdb, 0x0d, 0xb9, 0x55, 0x5b, 0x2a, 0x95, 0x07, 0xc9, 0x42, 0x7f, 0xcd, 0x82, 0xcc, 0x61,
	0x48, 0x19, 0xb4, 0xc0, 0x1a, 0x1d, 0x1e, 0xd1, 0x81, 0xd3, 0x25, 0xb6, 0xe7, 0x16, 0x8d, 0x8a,
	0xb1, 0x93, 0xa9, 0xdf, 0x1d, 0xc7, 0x26, 0x68, 0x29, 0x72, 0xe3, 0xf1, 0x24, 0x36, 0xe1, 0xc8,
	0xe9, 0xfb, 0xbb, 0x28, 0x21, 0x8a, 0x30, 0xd0, 0xa7, 0x86, 0x0b, 0xf7, 0x00, 0xa0, 0xa4, 0xcb,
	0xbc, 0x30, 0xe0, 0x5a, 0x52, 0x15, 0x63, 0x27, 0x57, 0x47, 0xe3, 0xd8, 0x5c, 0x6d, 0x49, 0xaa,
	0x50, 0xb2, 0xa9, 0x94, 0x4c, 0x05, 0x11, 0x5e, 0x55, 0x87, 0x86, 0x0b, 0xdf, 0x01, 0x29, 0xcf,
	0x2d, 0xa6, 0xc5, 0x05, 0xb6, 0xc6, 0xb1, 0x99, 0x12, 0x98, 0x55, 0x89, 0xe1, 0xb2, 0x29, 0xcf,
	0xe5, 0xd7, 0x25, 0x67, 0x8c, 0x44, 0x81, 0xe3, 0x73, 0x43, 0x99, 0x8a, 0xb1, 0xb3, 0x2a, 0xaf,
	0x6b, 0x29, 0x72, 0xf2, 0xba, 0x09, 0x51, 0x84, 0x81, 0x3e, 0x09, 0x5b, 0x19, 0x46, 0xce, 0x58,
	0xf1, 0x9a, 0xc0, 0x6f, 0x4c, 0x62, 0x73, 0x4d, 0x22, 0x38, 0x15, 0x61, 0xc1, 0x84, 0xbf, 0x02,
	0x59, 0x12, 0x30, 0x8f, 0x79, 0x84, 0x16, 0x97, 0x2b, 0xc6, 0xce, 0xda, 0x83, 0x5b, 0xd5, 0x85,
	0x38, 0x56, 0x2d, 0x25, 0x50, 0xdf, 0x9a, 0xc4, 0xe6, 0x86, 0xb2, 0xaa, 0x68, 0x08, 0x4f, 0xf1,
	0xc2, 0xa0, 0xd3, 0xa3, 0xc5, 0x95, 0x4a, 0x7a, 0xc1, 0xa0, 0xd3, 0xa3, 0xdc, 0xa0, 0xd3, 0xa3,
	0x70, 0x0f, 0x2c, 0x3b, 0x43, 0x76, 0x12, 0x46, 0xc5, 0xac, 0xb8, 0xd7, 0x8f, 0x27, 0xb1, 0x99,
	0x93, 0x62, 0x92, 0x8e, 0xbe, 0x7a, 0x79, 0x7f, 0x5b, 0xc5, 0x71, 0xcf, 0x75, 0x23, 0x42, 0x69,
	0x8b, 0x45, 0x5e, 0xd0, 0xc3, 0x0a, 0x08, 0x3b, 0x60, 0xa3, 0x1b, 0x06, 0xa7, 0x24, 0xa2, 0x8e,
	0x0e, 0xc6, 0xaa, 0xf0, 0xe8, 0x4f, 0xc7, 0xb1, 0x99, 0x7f, 0x94, 0x60, 0x09, 0x3f, 0xdd, 0x90,
	0xda, 0x17, 0x20, 0x08, 0xe7, 0x93, 0x94, 0x86, 0x0b, 0x43, 0x50, 0x88, 0xc8, 0x31, 0x89, 0x48,
	0xd0, 0x25, 0xae, 0x2d, 0x5e, 0x5f, 0x04, 0x95, 0xf4, 0xce, 0xda, 0x83, 0xf2, 0x39, 0x97, 0xf0,
	0xb4, 0xc2, 0x5a, 0xb8, 0x7e, 0xf7, 0xf3, 0xd8, 0x5c, 0x9a, 0xc4, 0xe6, 0x4d, 0x69, 0x69, 0x51,
	0x0b, 0xfa, 0xe7, 0xd7, 0x9f, 0xdd, 0x33, 0xf0, 0xc6, 0x8c, 0xce, 0xe1, 0x14, 0xda, 0x20, 0x1f,
	0x91, 0x81, 0x3f, 0xb2, 0x29, 0x61, 0xcc, 0x0b, 0x7a, 0xb4, 0xb8, 0x56, 0x31, 0x76, 0xf2, 0x0f,
	0xde, 0x3a, 0x67, 0x0e, 0x73, 0xb1, 0x96, 0x94, 0xaa, 0xdf, 0x9a, 0xc4, 0xe6, 0x75, 0x6d, 0x29,
	0x09, 0x47, 0x38, 0x17, 0x25, 0x04, 0x29, 0x3c, 0x06, 0xb9, 0x6e, 0x44, 0xe4, 0x8b, 0x5d, 0x87,
	0x91, 0xe2, 0xba, 0x88, 0x70, 0xa9, 0x2a, 0x8b, 0xaa, 0xaa, 0x8b, 0xaa, 0xda, 0xd6, 0x45, 0x55,
	0xff, 0x81, 0x7a, 0xca, 0xb6, 0x72, 0x5a, 0x12, 0x8e, 0x3e, 0xfe, 0x8f, 0x69, 0xc8, 0xb7, 0xac,
	0x6b, 0xc6, 0x63, 0x87, 0x11, 0x48, 0x40, 0xc1, 0x77, 0x28, 0xb3, 0x89, 0xeb, 0x31, 0xe2, 0x4a,
	0x53, 0xb9, 0xd7, 0x9a, 0x32, 0x67, 0x1e, 0x5b, 0x44, 0x0b, 0x4b, 0x38, 0xcf, 0xc9, 0x96, 0xa0,
	0x0a, 0x33, 0xbf, 0x04, 0xd7, 0xc2, 0x17, 0x01, 0x89, 0x8a, 0x79, 0x91, 0x39, 0x3b, 0x93, 0xd8,
	0x5c, 0x97, 0x78, 0x41, 0xbe, 0x3c, 0x71, 0x24, 0x6c, 0x37, 0xfb, 0xb7, 0x4f, 0x4c, 0xe3, 0x7f,
	0x9f, 0x98, 0x06, 0xfa, 0xc2, 0x00, 0xb9, 0xb9, 0x10, 0xc2, 0xa7, 0x20, 0xc3, 0x46, 0x03, 0x22,
	0x7a, 0x43, 0xfe, 0x01, 0xba, 0x3a, 0xe0, 0xed, 0xd1, 0x80, 0xcc, 0xe5, 0xf7, 0x68, 0x40, 0x78,
	0x7e, 0x8f, 0x06, 0x04, 0xfe, 0x1c, 0xac, 0x70, 0x90, 0xee, 0x10, 0x99, 0xfa, 0x9d, 0x71, 0x6c,
	0x2e, 0x73, 0xb8, 0x48, 0xc6, 0xbc, 0x44, 0x28, 0x11, 0x84, 0x97, 0xf9, 0xbf, 0x86, 0x0b, 0x6b,
	0x20, 0x3b, 0x08, 0xa9, 0xc7, 0x5d, 0xaa, 0xdb, 0xc3, 0xac, 0xd8, 0x34, 0x07, 0xe1, 0xa9, 0x50,
	0xe2, 0x31, 0xbf, 0x4f, 0x81, 0xac, 0x2e, 0x51, 0x88, 0x41, 0xf6, 0xc4, 0xa1, 0x27, 0xa2, 0x0e,
	0x0d, 0x91, 0xbc, 0xc5, 0x73, 0x6f, 0x69, 0x93, 0x33, 0xd6, 0x76, 0x7a, 0xf5, 0x3b, 0x2a, 0xd6,
	0xca, 0x8a, 0xc6, 0xa9, 0x74, 0x9d, 0xea, 0xe1, 0x3a, 0xfb, 0xbc, 0xc8, 0xc3, 0x80, 0x16, 0x53,
	0xdf, 0x4e, 0xa7, 0xc6, 0x69, 0x9d, 0xfa, 0x0c, 0xeb, 0x20, 0x33, 0x8c, 0x7c, 0x5a, 0x4c, 0x0b,
	0x7d, 0xdb, 0xe7, 0xf4, 0x75, 0x22, 0xbf, 0x5e, 0x54, 0xba, 0x94, 0x97, 0xb9, 0xbc, 0xd2, 0x23,
	0xb0, 0x09, 0x17, 0xfc, 0x0e, 0xac, 0xa8, 0x0b, 0xc0, 0x1f, 0x82, 0x6b, 0x94, 0x39, 0x11, 0x53,
	0x5d, 0xbe, 0x30, 0x4b, 0x12, 0x41, 0x46, 0x58, 0xb2, 0x61, 0x05, 0xa4, 0x49, 0xa0, 0x63, 0x94,
	0x9f, 0xc4, 0x26, 0xd0, 0x8d, 0xcd, 0x45, 0x98, 0xb3, 0xb8, 0x04, 0x73, 0x7a, 0x22, 0x1a, 0xab,
	0x49, 0x09, 0xe6, 0xf4, 0x10, 0xe6, 0xac, 0xc4, 0x05, 0x5e, 0x1a, 0x20, 0xdd, 0x89, 0xfc, 0xef,
	0xd7, 0xfa, 0x30, 0xf2, 0xcf, 0x5b, 0x1f, 0x46, 0x3e, 0xc2, 0x9c, 0x05, 0xdf, 0x05, 0x6b, 0xae,
	0x47, 0x07, 0xbe, 0x33, 0xb2, 0xb9, 0xa4, 0x1c, 0x13, 0x37, 0x66, 0x83, 0x21, 0xc1, 0x44, 0x18,
	0xa8, 0x53, 0x27, 0xf2, 0x13, 0xd7, 0xfe, 0x34, 0x05, 0xc0, 0x1e, 0x63, 0x4e, 0xf7, 0x84, 0x07,
	0xe6, 0xfb, 0x9a, 0x93, 0xdf, 0xb1, 0x04, 0x66, 0xb3, 0x31, 0x77, 0xf9, 0x6c, 0xec, 0x81, 0x95,
	0x6e, 0x18, 0x30, 0x12, 0x30, 0xf1, 0x60, 0x9e, 0x3a, 0x8b, 0x1d, 0x66, 0x2f, 0x18, 0xd5, 0xdf,
	0x9d, 0xd9, 0x51, 0xe2, 0xe8, 0x8b, 0x97, 0xf7, 0xdf, 0x5e, 0xcc, 0xb2, 0xd9, 0xdb, 0x1f, 0x49,
	0x29, 0xac, 0xb5, 0x27, 0x9c, 0xf4, 0x67, 0x03, 0x5c, 0x7b, 0x46, 0x5c, 0xcf, 0x91, 0x31, 0xf1,
	0xc4, 0xa3, 0x16, 0x62, 0xe2, 0x89, 0x98, 0x78, 0xf0, 0x67, 0x60, 0xb5, 0xef, 0xf5, 0x89, 0x2d,
	0x7a, 0x89, 0x8c, 0xdd, 0xf6, 0x24, 0x36, 0x0b, 0xaa, 0x1a, 0x34, 0x0b, 0xe1, 0x2c, 0xff, 0xcf,
	0xfb, 0xc8, 0xee, 0x7d, 0x6d, 0xe8, 0x1b, 0x5d, 0x10, 0xfd, 0x65, 0x99, 0x2f, 0x35, 0xbe, 0xcf,
	0x3b, 0xc6, 0x47, 0x43, 0x42, 0x45, 0xc7, 0x30, 0x84, 0xa5, 0x44, 0xc7, 0xd0, 0x1c, 0x84, 0xa7,
	0x42, 0x70, 0x08, 0x0a, 0x83, 0x28, 0x3c, 0xf5, 0x5c, 0xe2, 0xda, 0x4e, 0x40, 0x5f, 0x90, 0x48,
	0x97, 0xf3, 0xdd, 0x0b, 0xda, 0x9d, 0xef, 0x57, 0x0f, 0x95, 0xf4, 0x9e, 0x10, 0x5e, 0x9c, 0x72,
	0x8b, 0xba, 0xf4, 0x94, 0x1b, 0xcc, 0xa1, 0x28, 0xfc, 0x80, 0x6f, 0x18, 0x6a, 0x28, 0xa4, 0x5f,
	0x3b, 0x14, 0x2a, 0xf3, 0xfd, 0x43, 0x23, 0x13, 0xa3, 0x67, 0x85, 0x04, 0x72, 0x1c, 0x7c, 0x08,
	0x6e, 0x3a, 0xbe, 0x1f, 0xbe, 0xa0, 0x76, 0x7f, 0xe8, 0x33, 0x6f, 0xe0, 0x93, 0xe9, 0xb3, 0x78,
	0x6a, 0x64, 0xeb, 0x68, 0x12, 0x9b, 0x65, 0xb5, 0x5a, 0x5c, 0x2c, 0x88, 0xf0, 0x75, 0xc9, 0x79,
	0xa6, 0x18, 0xfa, 0xd2, 0x4d, 0xb0, 0xa5, 0x20, 0x52, 0x52, 0x0c, 0x27, 0x2a, 0x56, 0xa9, 0xac,
	0x18, 0x5c, 0xb7, 0xe7, 0xf4, 0x2a, 0x75, 0x52, 0x0a, 0xe1, 0x4d, 0x49, 0x96, 0xca, 0xf8, 0x00,
	0xa3, 0xf0, 0x23, 0xb0, 0x75, 0xec, 0xf1, 0x2d, 0x8d, 0x39, 0xbe, 0x3f, 0xb2, 0x23, 0x42, 0x87,
	0x3e, 0xd3, 0x2b, 0xd7, 0xdb, 0x17, 0xfa, 0xbf, 0xcd, 0x25, 0xb1, 0x14, 0xac, 0x97, 0x27, 0xb1,
	0x59, 0x92, 0x36, 0x2f, 0xd0, 0x83, 0xf0, 0xa6, 0xa0, 0x26, 0x21, 0xa5, 0x97, 0x06, 0xc8, 0xcf,
	0x87, 0x70, 0xba, 0x12, 0x1a, 0x57, 0xad, 0x84, 0x14, 0xac, 0x39, 0xd3, 0xb4, 0xd3, 0x29, 0x72,
	0x71, 0x99, 0xbd, 0x37, 0xeb, 0x06, 0x09, 0xc8, 0x37, 0x2c, 0xb5, 0xa4, 0x95, 0x59, 0xb9, 0x7d,
	0xdb, 0x7a, 0xf8, 0x2a, 0x05, 0x40, 0x87, 0x92, 0x48, 0xbd, 0xf0, 0xcd, 0xb6, 0x30, 0x01, 0xf3,
	0xc5, 0xd6, 0x2e, 0xfb, 0x98, 0x82, 0xf9, 0xfe, 0x3c, 0xcc, 0xf7, 0x35, 0xcc, 0xe7, 0x9b, 0xfa,
	0xfb, 0x60, 0x43, 0x67, 0x90, 0x17, 0xb8, 0xe4, 0x8c, 0xf0, 0x0c, 0x4e, 0xef, 0xe4, 0x44, 0xa6,
	0xa9, 0xf5, 0x75, 0x41, 0x40, 0x55, 0x5b, 0x5e, 0x91, 0x1b, 0x92, 0x0a, 0xdf, 0x03, 0x99, 0x21,
	0x25, 0x91, 0xda, 0xf9, 0x7f, 0x94, 0x18, 0x9e, 0xf4, 0xaa, 0x05, 0x49, 0x80, 0x12, 0x2d, 0xef,
	0x0f, 0x29, 0x50, 0x58, 0x4c, 0x41, 0x48, 0xc0, 0x8a, 0x4e, 0x5b, 0xb9, 0x59, 0x54, 0x5f, 0x9b,
	0xb6, 0x55, 0x19, 0x15, 0x79, 0xaa, 0xdf, 0x56, 0xb5, 0x9d, 0xd7, 0xcb, 0xab, 0xcc, 0x5d, 0x55,
	0xd6, 0xea, 0x58, 0xfa, 0x2d, 0x58, 0x4f, 0xa2, 0xe0, 0x2e, 0x58, 0x57, 0x35, 0x28, 0x9e, 0x2e,
	0x42, 0x9a, 0xab, 0xdf, 0x9c, 0xc4, 0xe6, 0x56, 0xd2, 0x33, 0x92, 0x8b, 0xf0, 0x9a, 0x3c, 0x0a,
	0x87, 0xf0, 0x71, 0x7c, 0x1a, 0x32, 0x42, 0x55, 0x10, 0x13, 0xe3, 0x58, 0x90, 0x11, 0x96, 0xec,
	0x44, 0xf6, 0xcd, 0x7c, 0x30, 0x00, 0xcb, 0x87, 0x4e, 0xe4, 0xf4, 0xf9, 0xae, 0xb2, 0xd1, 0x77,
	0xce, 0x6c, 0x5e, 0x1c, 0xb6, 0x4f, 0x82, 0x1e, 0x3b, 0x51, 0x97, 0x28, 0xcd, 0xc2, 0xb3, 0x20,
	0x80, 0x70, 0xae, 0xef, 0x9c, 0xf1, 0x9d, 0x64, 0x5f, 0x9c, 0x77, 0x91, 0xd6, 0xfb, 0xa7, 0xaf,
	0x3f, 0xbb, 0x77, 0x5d, 0x7d, 0x47, 0x9f, 0xa9, 0x2f, 0x69, 0x69, 0x07, 0xfd, 0x2b, 0x05, 0x8a,
	0x3c, 0xc5, 0x9a, 0x7c, 0x5b, 0x6d, 0x47, 0x4e, 0x40, 0x8f, 0xb9, 0x17, 0x44, 0x03, 0x7f, 0xc3,
	0x89, 0xbd, 0x07, 0x96, 0x29, 0x09, 0x5c, 0x12, 0xa9, 0xa1, 0x96, 0xf8, 0x6a, 0x93, 0xf4, 0x2b,
	0xbe, 0xda, 0xa4, 0x00, 0x7c, 0x0a, 0xb2, 0x11, 0xe9, 0x12, 0xef, 0x94, 0x44, 0x6a, 0x57, 0xf9,
	0xc9, 0xac, 0xcf, 0x6b, 0xce, 0xe5, 0x6a, 0xa6, 0xe0, 0x59, 0x88, 0xee, 0xfd, 0xdd, 0x00, 0x9b,
	0xe7, 0x16, 0x73, 0xf8, 0x0e, 0x30, 0x0f, 0x9b, 0xad, 0xb6, 0x8d, 0xad, 0x27, 0x16, 0xb6, 0x0e,
	0x1e, 0x59, 0x76, 0xfb, 0xf9, 0xa1, 0x65, 0x77, 0x0e, 0x5a, 0x87, 0xd6, 0xa3, 0xc6, 0x93, 0x86,
	0xf5, 0xb8, 0xb0, 0x04, 0xdf, 0x02, 0xb7, 0x2e, 0x12, 0xc2, 0xd6, 0xe1, 0xfe, 0xf3, 0x82, 0x71,
	0x19, 0xfb, 0xd7, 0x9d, 0x66, 0xdb, 0x2a, 0xa4, 0x60, 0x19, 0x94, 0x2e, 0x41, 0x37, 0x5b, 0xed,
	0x42, 0xba, 0x94, 0xf9, 0xe3, 0x3f, 0xca, 0x4b, 0xf7, 0x3e, 0x35, 0xc0, 0x7a, 0xf2, 0xcb, 0x8d,
	0x6b, 0x15, 0x06, 0xec, 0x96, 0xd5, 0x6e, 0x37, 0x0e, 0x9e, 0x2e, 0xdc, 0xa9, 0x04, 0x6e, 0xcc,
	0xb3, 0xad, 0xdf, 0x58, 0xf8, 0x79, 0xf3, 0xc0, 0x2a, 0x18, 0xf0, 0x36, 0xb8, 0x39, 0xcf, 0x7b,
	0xd2, 0xdc, 0xdf, 0x6f, 0x7e, 0x60, 0xe1, 0x56, 0x21, 0x05, 0x8b, 0x60, 0x7b, 0x9e, 0xf9, 0xac,
	0xd3, 0xee, 0xec, 0xed, 0x17, 0xd2, 0xe7, 0x55, 0x3e, 0xb3, 0x0e, 0xda, 0x8d, 0xe6, 0x41, 0xab,
	0x90, 0x91, 0x97, 0xac, 0xbf, 0xff, 0xf9, 0xb8, 0x6c, 0x7c, 0x39, 0x2e, 0x1b, 0xff, 0x1d, 0x97,
	0x8d, 0x8f, 0x5f, 0x95, 0x97, 0xbe, 0x7c, 0x55, 0x5e, 0xfa, 0xf7, 0xab, 0xf2, 0xd2, 0x87, 0xd5,
	0x9e, 0xc7, 0x4e, 0x86, 0x47, 0xd5, 0x6e, 0xd8, 0xaf, 0xc9, 0x84, 0xbd, 0xef, 0x3b, 0x47, 0x54,
	0xfd, 0xaf, 0x9d, 0xfe, 0x62, 0x9a, 0xbf, 0x7c, 0xa5, 0xa1, 0x47, 0xcb, 0x62, 0x34, 0x3c, 0xfc,
	0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0x91, 0x80, 0x1d, 0x26, 0x12, 0x00, 0x00,
}

func (this *Post) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Post)
	if !ok {
		that2, ok := that.(Post)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if this.SectionID != that1.SectionID {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	if !this.Entities.Equal(that1.Entities) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Author != that1.Author {
		return false
	}
	if this.ConversationID != that1.ConversationID {
		return false
	}
	if len(this.ReferencedPosts) != len(that1.ReferencedPosts) {
		return false
	}
	for i := range this.ReferencedPosts {
		if !this.ReferencedPosts[i].Equal(&that1.ReferencedPosts[i]) {
			return false
		}
	}
	if this.ReplySettings != that1.ReplySettings {
		return false
	}
	if !this.CreationDate.Equal(that1.CreationDate) {
		return false
	}
	if that1.LastEditedDate == nil {
		if this.LastEditedDate != nil {
			return false
		}
	} else if !this.LastEditedDate.Equal(*that1.LastEditedDate) {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	return true
}
func (this *PostReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostReference)
	if !ok {
		that2, ok := that.(PostReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.PostID != that1.PostID {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	return true
}
func (this *Entities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Entities)
	if !ok {
		that2, ok := that.(Entities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Hashtags) != len(that1.Hashtags) {
		return false
	}
	for i := range this.Hashtags {
		if !this.Hashtags[i].Equal(&that1.Hashtags[i]) {
			return false
		}
	}
	if len(this.Mentions) != len(that1.Mentions) {
		return false
	}
	for i := range this.Mentions {
		if !this.Mentions[i].Equal(&that1.Mentions[i]) {
			return false
		}
	}
	if len(this.Urls) != len(that1.Urls) {
		return false
	}
	for i := range this.Urls {
		if !this.Urls[i].Equal(&that1.Urls[i]) {
			return false
		}
	}
	return true
}
func (this *TextTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TextTag)
	if !ok {
		that2, ok := that.(TextTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if this.Tag != that1.Tag {
		return false
	}
	return true
}
func (this *Url) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Url)
	if !ok {
		that2, ok := that.(Url)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.DisplayUrl != that1.DisplayUrl {
		return false
	}
	return true
}
func (this *Attachment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Attachment)
	if !ok {
		that2, ok := that.(Attachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if this.PostID != that1.PostID {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !this.Content.Equal(that1.Content) {
		return false
	}
	return true
}
func (this *Media) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Media)
	if !ok {
		that2, ok := that.(Media)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	if this.MimeType != that1.MimeType {
		return false
	}
	return true
}
func (this *Poll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Poll)
	if !ok {
		that2, ok := that.(Poll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Question != that1.Question {
		return false
	}
	if len(this.ProvidedAnswers) != len(that1.ProvidedAnswers) {
		return false
	}
	for i := range this.ProvidedAnswers {
		if !this.ProvidedAnswers[i].Equal(&that1.ProvidedAnswers[i]) {
			return false
		}
	}
	if !this.EndDate.Equal(that1.EndDate) {
		return false
	}
	if this.AllowsMultipleAnswers != that1.AllowsMultipleAnswers {
		return false
	}
	if this.AllowsAnswerEdits != that1.AllowsAnswerEdits {
		return false
	}
	if !this.FinalTallyResults.Equal(that1.FinalTallyResults) {
		return false
	}
	return true
}
func (this *Poll_ProvidedAnswer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Poll_ProvidedAnswer)
	if !ok {
		that2, ok := that.(Poll_ProvidedAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	if len(this.Attachments) != len(that1.Attachments) {
		return false
	}
	for i := range this.Attachments {
		if !this.Attachments[i].Equal(that1.Attachments[i]) {
			return false
		}
	}
	return true
}
func (this *UserAnswer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserAnswer)
	if !ok {
		that2, ok := that.(UserAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if this.PostID != that1.PostID {
		return false
	}
	if this.PollID != that1.PollID {
		return false
	}
	if len(this.AnswersIndexes) != len(that1.AnswersIndexes) {
		return false
	}
	for i := range this.AnswersIndexes {
		if this.AnswersIndexes[i] != that1.AnswersIndexes[i] {
			return false
		}
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *PollTallyResults) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PollTallyResults)
	if !ok {
		that2, ok := that.(PollTallyResults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(&that1.Results[i]) {
			return false
		}
	}
	return true
}
func (this *PollTallyResults_AnswerResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PollTallyResults_AnswerResult)
	if !ok {
		that2, ok := that.(PollTallyResults_AnswerResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AnswerIndex != that1.AnswerIndex {
		return false
	}
	if this.Votes != that1.Votes {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxTextLength != that1.MaxTextLength {
		return false
	}
	return true
}
func (this *PostOwnerTransferRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostOwnerTransferRequest)
	if !ok {
		that2, ok := that.(PostOwnerTransferRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubspaceID != that1.SubspaceID {
		return false
	}
	if this.PostID != that1.PostID {
		return false
	}
	if this.Sender != that1.Sender {
		return false
	}
	if this.Receiver != that1.Receiver {
		return false
	}
	return true
}
func (m *Post) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Post) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Post) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x72
	}
	if m.LastEditedDate != nil {
		n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.LastEditedDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.LastEditedDate):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintModels(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x6a
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreationDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreationDate):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintModels(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x62
	if m.ReplySettings != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.ReplySettings))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ReferencedPosts) > 0 {
		for iNdEx := len(m.ReferencedPosts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReferencedPosts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.ConversationID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.ConversationID))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Entities != nil {
		{
			size, err := m.Entities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintModels(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0x22
	}
	if m.ID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x18
	}
	if m.SectionID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SectionID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PostReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PostReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x18
	}
	if m.PostID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Urls) > 0 {
		for iNdEx := len(m.Urls) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Urls[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Mentions) > 0 {
		for iNdEx := len(m.Mentions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Mentions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hashtags) > 0 {
		for iNdEx := len(m.Hashtags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hashtags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TextTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Url) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayUrl) > 0 {
		i -= len(m.DisplayUrl)
		copy(dAtA[i:], m.DisplayUrl)
		i = encodeVarintModels(dAtA, i, uint64(len(m.DisplayUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Attachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x18
	}
	if m.PostID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Media) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintModels(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Poll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Poll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FinalTallyResults != nil {
		{
			size, err := m.FinalTallyResults.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AllowsAnswerEdits {
		i--
		if m.AllowsAnswerEdits {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AllowsMultipleAnswers {
		i--
		if m.AllowsMultipleAnswers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EndDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EndDate):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintModels(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	if len(m.ProvidedAnswers) > 0 {
		for iNdEx := len(m.ProvidedAnswers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProvidedAnswers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Question) > 0 {
		i -= len(m.Question)
		copy(dAtA[i:], m.Question)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Question)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Poll_ProvidedAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poll_ProvidedAnswer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Poll_ProvidedAnswer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attachments) > 0 {
		for iNdEx := len(m.Attachments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attachments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAnswer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAnswer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintModels(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AnswersIndexes) > 0 {
		dAtA8 := make([]byte, len(m.AnswersIndexes)*10)
		var j7 int
		for _, num := range m.AnswersIndexes {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintModels(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if m.PollID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.PollID))
		i--
		dAtA[i] = 0x18
	}
	if m.PostID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PollTallyResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollTallyResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PollTallyResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PollTallyResults_AnswerResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollTallyResults_AnswerResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PollTallyResults_AnswerResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Votes != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Votes))
		i--
		dAtA[i] = 0x10
	}
	if m.AnswerIndex != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.AnswerIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxTextLength != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.MaxTextLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PostOwnerTransferRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostOwnerTransferRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PostOwnerTransferRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PostID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Post) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	if m.SectionID != 0 {
		n += 1 + sovModels(uint64(m.SectionID))
	}
	if m.ID != 0 {
		n += 1 + sovModels(uint64(m.ID))
	}
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Entities != nil {
		l = m.Entities.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.ConversationID != 0 {
		n += 1 + sovModels(uint64(m.ConversationID))
	}
	if len(m.ReferencedPosts) > 0 {
		for _, e := range m.ReferencedPosts {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.ReplySettings != 0 {
		n += 1 + sovModels(uint64(m.ReplySettings))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreationDate)
	n += 1 + l + sovModels(uint64(l))
	if m.LastEditedDate != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.LastEditedDate)
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *PostReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	if m.PostID != 0 {
		n += 1 + sovModels(uint64(m.PostID))
	}
	if m.Position != 0 {
		n += 1 + sovModels(uint64(m.Position))
	}
	return n
}

func (m *Entities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hashtags) > 0 {
		for _, e := range m.Hashtags {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Mentions) > 0 {
		for _, e := range m.Mentions {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Urls) > 0 {
		for _, e := range m.Urls {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *TextTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovModels(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovModels(uint64(m.End))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovModels(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovModels(uint64(m.End))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.DisplayUrl)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovModels(uint64(m.PostID))
	}
	if m.ID != 0 {
		n += 1 + sovModels(uint64(m.ID))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Poll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Question)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.ProvidedAnswers) > 0 {
		for _, e := range m.ProvidedAnswers {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EndDate)
	n += 1 + l + sovModels(uint64(l))
	if m.AllowsMultipleAnswers {
		n += 2
	}
	if m.AllowsAnswerEdits {
		n += 2
	}
	if m.FinalTallyResults != nil {
		l = m.FinalTallyResults.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Poll_ProvidedAnswer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *UserAnswer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovModels(uint64(m.PostID))
	}
	if m.PollID != 0 {
		n += 1 + sovModels(uint64(m.PollID))
	}
	if len(m.AnswersIndexes) > 0 {
		l = 0
		for _, e := range m.AnswersIndexes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *PollTallyResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *PollTallyResults_AnswerResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnswerIndex != 0 {
		n += 1 + sovModels(uint64(m.AnswerIndex))
	}
	if m.Votes != 0 {
		n += 1 + sovModels(uint64(m.Votes))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxTextLength != 0 {
		n += 1 + sovModels(uint64(m.MaxTextLength))
	}
	return n
}

func (m *PostOwnerTransferRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovModels(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovModels(uint64(m.PostID))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Post) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Post: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Post: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionID", wireType)
			}
			m.SectionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entities == nil {
				m.Entities = &Entities{}
			}
			if err := m.Entities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationID", wireType)
			}
			m.ConversationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedPosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferencedPosts = append(m.ReferencedPosts, PostReference{})
			if err := m.ReferencedPosts[len(m.ReferencedPosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplySettings", wireType)
			}
			m.ReplySettings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplySettings |= ReplySetting(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreationDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEditedDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEditedDate == nil {
				m.LastEditedDate = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.LastEditedDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PostReferenceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashtags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashtags = append(m.Hashtags, TextTag{})
			if err := m.Hashtags[len(m.Hashtags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mentions = append(m.Mentions, TextTag{})
			if err := m.Mentions[len(m.Mentions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Urls = append(m.Urls, Url{})
			if err := m.Urls[len(m.Urls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Url) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Url: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Url: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &types.Any{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Media) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Media: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Media: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Poll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Poll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Question = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvidedAnswers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvidedAnswers = append(m.ProvidedAnswers, Poll_ProvidedAnswer{})
			if err := m.ProvidedAnswers[len(m.ProvidedAnswers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowsMultipleAnswers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowsMultipleAnswers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowsAnswerEdits", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowsAnswerEdits = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalTallyResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalTallyResults == nil {
				m.FinalTallyResults = &PollTallyResults{}
			}
			if err := m.FinalTallyResults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poll_ProvidedAnswer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvidedAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvidedAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &types.Any{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAnswer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollID", wireType)
			}
			m.PollID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AnswersIndexes = append(m.AnswersIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AnswersIndexes) == 0 {
					m.AnswersIndexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AnswersIndexes = append(m.AnswersIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswersIndexes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollTallyResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PollTallyResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PollTallyResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, PollTallyResults_AnswerResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollTallyResults_AnswerResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnswerResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnswerResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswerIndex", wireType)
			}
			m.AnswerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnswerIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			m.Votes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Votes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTextLength", wireType)
			}
			m.MaxTextLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTextLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostOwnerTransferRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostOwnerTransferRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostOwnerTransferRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
