// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: desmos/posts/v3/msgs.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreatePost represents the message to be used to create a post.
type MsgCreatePost struct {
	// Id of the subspace inside which the post must be created
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the section inside which the post must be created
	SectionID uint32 `protobuf:"varint,2,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty" yaml:"section_id"`
	// (optional) External id for this post
	ExternalID string `protobuf:"bytes,3,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty" yaml:"external_id"`
	// (optional) Text of the post
	Text string `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty" yaml:"text"`
	// (optional) Entities connected to this post
	Entities *Entities `protobuf:"bytes,5,opt,name=entities,proto3" json:"entities,omitempty" yaml:"entities"`
	// Tags connected to this post
	Tags []string `protobuf:"bytes,6,rep,name=tags,proto3" json:"tags,omitempty" yaml:"tags"`
	// Attachments of the post
	Attachments []*types.Any `protobuf:"bytes,7,rep,name=attachments,proto3" json:"attachments,omitempty" yaml:"attachments"`
	// Author of the post
	Author string `protobuf:"bytes,8,opt,name=author,proto3" json:"author,omitempty" yaml:"author"`
	// (optional) Id of the original post of the conversation
	ConversationID uint64 `protobuf:"varint,9,opt,name=conversation_id,json=conversationId,proto3" json:"conversation_id,omitempty" yaml:"conversation_id"`
	// Reply settings of this post
	ReplySettings ReplySetting `protobuf:"varint,10,opt,name=reply_settings,json=replySettings,proto3,enum=desmos.posts.v3.ReplySetting" json:"reply_settings,omitempty" yaml:"reply_settings"`
	// A list this posts references (either as a reply, repost or quote)
	ReferencedPosts []PostReference `protobuf:"bytes,11,rep,name=referenced_posts,json=referencedPosts,proto3" json:"referenced_posts" yaml:"referenced_posts"`
}

func (m *MsgCreatePost) Reset()         { *m = MsgCreatePost{} }
func (m *MsgCreatePost) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePost) ProtoMessage()    {}
func (*MsgCreatePost) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{0}
}
func (m *MsgCreatePost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePost.Merge(m, src)
}
func (m *MsgCreatePost) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePost) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePost.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePost proto.InternalMessageInfo

func (m *MsgCreatePost) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *MsgCreatePost) GetSectionID() uint32 {
	if m != nil {
		return m.SectionID
	}
	return 0
}

func (m *MsgCreatePost) GetExternalID() string {
	if m != nil {
		return m.ExternalID
	}
	return ""
}

func (m *MsgCreatePost) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *MsgCreatePost) GetEntities() *Entities {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *MsgCreatePost) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MsgCreatePost) GetAttachments() []*types.Any {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func (m *MsgCreatePost) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *MsgCreatePost) GetConversationID() uint64 {
	if m != nil {
		return m.ConversationID
	}
	return 0
}

func (m *MsgCreatePost) GetReplySettings() ReplySetting {
	if m != nil {
		return m.ReplySettings
	}
	return REPLY_SETTING_UNSPECIFIED
}

func (m *MsgCreatePost) GetReferencedPosts() []PostReference {
	if m != nil {
		return m.ReferencedPosts
	}
	return nil
}

// MsgCreatePostResponse defines the Msg/CreatePost response type.
type MsgCreatePostResponse struct {
	// Id of the newly created post
	PostID uint64 `protobuf:"varint,1,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Creation date of the post
	CreationDate time.Time `protobuf:"bytes,2,opt,name=creation_date,json=creationDate,proto3,stdtime" json:"creation_date" yaml:"creation_date"`
}

func (m *MsgCreatePostResponse) Reset()         { *m = MsgCreatePostResponse{} }
func (m *MsgCreatePostResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePostResponse) ProtoMessage()    {}
func (*MsgCreatePostResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{1}
}
func (m *MsgCreatePostResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePostResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePostResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePostResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePostResponse.Merge(m, src)
}
func (m *MsgCreatePostResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePostResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePostResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePostResponse proto.InternalMessageInfo

func (m *MsgCreatePostResponse) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *MsgCreatePostResponse) GetCreationDate() time.Time {
	if m != nil {
		return m.CreationDate
	}
	return time.Time{}
}

// MsgEditPost represents the message to be used to edit a post.
type MsgEditPost struct {
	// Id of the subspace inside which the post is
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post to edit
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// New text of the post. If set to [do-not-modify] it will change the current
	// post's text.
	Text string `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty" yaml:"text"`
	// New entities connected to this post. These will always replace the current
	// post's entities
	Entities *Entities `protobuf:"bytes,4,opt,name=entities,proto3" json:"entities,omitempty" yaml:"entities"`
	// New tags connected to this post. These will always replace the current
	// post's tags
	Tags []string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" yaml:"tags"`
	// Editor of the post
	Editor string `protobuf:"bytes,6,opt,name=editor,proto3" json:"editor,omitempty" yaml:"editor"`
}

func (m *MsgEditPost) Reset()         { *m = MsgEditPost{} }
func (m *MsgEditPost) String() string { return proto.CompactTextString(m) }
func (*MsgEditPost) ProtoMessage()    {}
func (*MsgEditPost) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{2}
}
func (m *MsgEditPost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditPost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditPost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditPost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditPost.Merge(m, src)
}
func (m *MsgEditPost) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditPost) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditPost.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditPost proto.InternalMessageInfo

func (m *MsgEditPost) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *MsgEditPost) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *MsgEditPost) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *MsgEditPost) GetEntities() *Entities {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *MsgEditPost) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MsgEditPost) GetEditor() string {
	if m != nil {
		return m.Editor
	}
	return ""
}

// MsgCreatePostResponse defines the Msg/EditPost response type.
type MsgEditPostResponse struct {
	// Edit date of the post
	EditDate time.Time `protobuf:"bytes,1,opt,name=edit_date,json=editDate,proto3,stdtime" json:"edit_date" yaml:"edit_date"`
}

func (m *MsgEditPostResponse) Reset()         { *m = MsgEditPostResponse{} }
func (m *MsgEditPostResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEditPostResponse) ProtoMessage()    {}
func (*MsgEditPostResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{3}
}
func (m *MsgEditPostResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditPostResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditPostResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditPostResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditPostResponse.Merge(m, src)
}
func (m *MsgEditPostResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditPostResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditPostResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditPostResponse proto.InternalMessageInfo

func (m *MsgEditPostResponse) GetEditDate() time.Time {
	if m != nil {
		return m.EditDate
	}
	return time.Time{}
}

// MsgDeletePost represents the message used when deleting a post.
type MsgDeletePost struct {
	// Id of the subspace containing the post
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post to be deleted
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// User that is deleting the post
	Signer string `protobuf:"bytes,3,opt,name=signer,proto3" json:"signer,omitempty" yaml:"signer"`
}

func (m *MsgDeletePost) Reset()         { *m = MsgDeletePost{} }
func (m *MsgDeletePost) String() string { return proto.CompactTextString(m) }
func (*MsgDeletePost) ProtoMessage()    {}
func (*MsgDeletePost) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{4}
}
func (m *MsgDeletePost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeletePost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeletePost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeletePost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeletePost.Merge(m, src)
}
func (m *MsgDeletePost) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeletePost) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeletePost.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeletePost proto.InternalMessageInfo

func (m *MsgDeletePost) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *MsgDeletePost) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *MsgDeletePost) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

// MsgDeletePostResponse represents the Msg/DeletePost response type
type MsgDeletePostResponse struct {
}

func (m *MsgDeletePostResponse) Reset()         { *m = MsgDeletePostResponse{} }
func (m *MsgDeletePostResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeletePostResponse) ProtoMessage()    {}
func (*MsgDeletePostResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{5}
}
func (m *MsgDeletePostResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeletePostResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeletePostResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeletePostResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeletePostResponse.Merge(m, src)
}
func (m *MsgDeletePostResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeletePostResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeletePostResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeletePostResponse proto.InternalMessageInfo

// MsgAddPostAttachment represents the message that should be
// used when adding an attachment to post
type MsgAddPostAttachment struct {
	// Id of the subspace containing the post
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post to which to add the attachment
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Content of the attachment
	Content *types.Any `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty" yaml:"content"`
	// Editor of the post
	Editor string `protobuf:"bytes,4,opt,name=editor,proto3" json:"editor,omitempty" yaml:"editor"`
}

func (m *MsgAddPostAttachment) Reset()         { *m = MsgAddPostAttachment{} }
func (m *MsgAddPostAttachment) String() string { return proto.CompactTextString(m) }
func (*MsgAddPostAttachment) ProtoMessage()    {}
func (*MsgAddPostAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{6}
}
func (m *MsgAddPostAttachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddPostAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddPostAttachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddPostAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddPostAttachment.Merge(m, src)
}
func (m *MsgAddPostAttachment) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddPostAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddPostAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddPostAttachment proto.InternalMessageInfo

func (m *MsgAddPostAttachment) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *MsgAddPostAttachment) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *MsgAddPostAttachment) GetContent() *types.Any {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *MsgAddPostAttachment) GetEditor() string {
	if m != nil {
		return m.Editor
	}
	return ""
}

// MsgAddPostAttachmentResponse defines the Msg/AddPostAttachment response type.
type MsgAddPostAttachmentResponse struct {
	// New id of the uploaded attachment
	AttachmentID uint32 `protobuf:"varint,1,opt,name=attachment_id,json=attachmentId,proto3" json:"attachment_id,omitempty" yaml:"attachment_id"`
	// Edit date of the post
	EditDate time.Time `protobuf:"bytes,2,opt,name=edit_date,json=editDate,proto3,stdtime" json:"edit_date" yaml:"edit_date"`
}

func (m *MsgAddPostAttachmentResponse) Reset()         { *m = MsgAddPostAttachmentResponse{} }
func (m *MsgAddPostAttachmentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddPostAttachmentResponse) ProtoMessage()    {}
func (*MsgAddPostAttachmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{7}
}
func (m *MsgAddPostAttachmentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddPostAttachmentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddPostAttachmentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddPostAttachmentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddPostAttachmentResponse.Merge(m, src)
}
func (m *MsgAddPostAttachmentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddPostAttachmentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddPostAttachmentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddPostAttachmentResponse proto.InternalMessageInfo

func (m *MsgAddPostAttachmentResponse) GetAttachmentID() uint32 {
	if m != nil {
		return m.AttachmentID
	}
	return 0
}

func (m *MsgAddPostAttachmentResponse) GetEditDate() time.Time {
	if m != nil {
		return m.EditDate
	}
	return time.Time{}
}

// MsgRemovePostAttachment represents the message to be used when
// removing an attachment from a post
type MsgRemovePostAttachment struct {
	// Id of the subspace containing the post
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post from which to remove the attachment
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Id of the attachment to be removed
	AttachmentID uint32 `protobuf:"varint,3,opt,name=attachment_id,json=attachmentId,proto3" json:"attachment_id,omitempty" yaml:"attachment_id"`
	// User that is removing the attachment
	Editor string `protobuf:"bytes,4,opt,name=editor,proto3" json:"editor,omitempty" yaml:"editor"`
}

func (m *MsgRemovePostAttachment) Reset()         { *m = MsgRemovePostAttachment{} }
func (m *MsgRemovePostAttachment) String() string { return proto.CompactTextString(m) }
func (*MsgRemovePostAttachment) ProtoMessage()    {}
func (*MsgRemovePostAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{8}
}
func (m *MsgRemovePostAttachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemovePostAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemovePostAttachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemovePostAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemovePostAttachment.Merge(m, src)
}
func (m *MsgRemovePostAttachment) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemovePostAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemovePostAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemovePostAttachment proto.InternalMessageInfo

func (m *MsgRemovePostAttachment) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *MsgRemovePostAttachment) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *MsgRemovePostAttachment) GetAttachmentID() uint32 {
	if m != nil {
		return m.AttachmentID
	}
	return 0
}

func (m *MsgRemovePostAttachment) GetEditor() string {
	if m != nil {
		return m.Editor
	}
	return ""
}

// MsgRemovePostAttachmentResponse defines the
// Msg/RemovePostAttachment response type.
type MsgRemovePostAttachmentResponse struct {
	// Edit date of the post
	EditDate time.Time `protobuf:"bytes,1,opt,name=edit_date,json=editDate,proto3,stdtime" json:"edit_date" yaml:"edit_date"`
}

func (m *MsgRemovePostAttachmentResponse) Reset()         { *m = MsgRemovePostAttachmentResponse{} }
func (m *MsgRemovePostAttachmentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemovePostAttachmentResponse) ProtoMessage()    {}
func (*MsgRemovePostAttachmentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{9}
}
func (m *MsgRemovePostAttachmentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemovePostAttachmentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemovePostAttachmentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemovePostAttachmentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemovePostAttachmentResponse.Merge(m, src)
}
func (m *MsgRemovePostAttachmentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemovePostAttachmentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemovePostAttachmentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemovePostAttachmentResponse proto.InternalMessageInfo

func (m *MsgRemovePostAttachmentResponse) GetEditDate() time.Time {
	if m != nil {
		return m.EditDate
	}
	return time.Time{}
}

// MsgAnswerPoll represents the message used to answer a poll
type MsgAnswerPoll struct {
	// Id of the subspace containing the post
	SubspaceID uint64 `protobuf:"varint,1,opt,name=subspace_id,json=subspaceId,proto3" json:"subspace_id,omitempty" yaml:"subspace_id"`
	// Id of the post that contains the poll to be answered
	PostID uint64 `protobuf:"varint,2,opt,name=post_id,json=postId,proto3" json:"post_id,omitempty" yaml:"post_id"`
	// Id of the poll to be answered
	PollID uint32 `protobuf:"varint,3,opt,name=poll_id,json=pollId,proto3" json:"poll_id,omitempty" yaml:"poll_id"`
	// Indexes of the answer inside the ProvidedAnswers array
	AnswersIndexes []uint32 `protobuf:"varint,4,rep,packed,name=answers_indexes,json=answersIndexes,proto3" json:"answers_indexes,omitempty" yaml:"answers_indexes"`
	// Address of the user answering the poll
	Signer string `protobuf:"bytes,5,opt,name=signer,proto3" json:"signer,omitempty" yaml:"signer"`
}

func (m *MsgAnswerPoll) Reset()         { *m = MsgAnswerPoll{} }
func (m *MsgAnswerPoll) String() string { return proto.CompactTextString(m) }
func (*MsgAnswerPoll) ProtoMessage()    {}
func (*MsgAnswerPoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{10}
}
func (m *MsgAnswerPoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAnswerPoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAnswerPoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAnswerPoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAnswerPoll.Merge(m, src)
}
func (m *MsgAnswerPoll) XXX_Size() int {
	return m.Size()
}
func (m *MsgAnswerPoll) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAnswerPoll.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAnswerPoll proto.InternalMessageInfo

func (m *MsgAnswerPoll) GetSubspaceID() uint64 {
	if m != nil {
		return m.SubspaceID
	}
	return 0
}

func (m *MsgAnswerPoll) GetPostID() uint64 {
	if m != nil {
		return m.PostID
	}
	return 0
}

func (m *MsgAnswerPoll) GetPollID() uint32 {
	if m != nil {
		return m.PollID
	}
	return 0
}

func (m *MsgAnswerPoll) GetAnswersIndexes() []uint32 {
	if m != nil {
		return m.AnswersIndexes
	}
	return nil
}

func (m *MsgAnswerPoll) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

// MsgAnswerPollResponse represents the MSg/AnswerPoll response type
type MsgAnswerPollResponse struct {
}

func (m *MsgAnswerPollResponse) Reset()         { *m = MsgAnswerPollResponse{} }
func (m *MsgAnswerPollResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAnswerPollResponse) ProtoMessage()    {}
func (*MsgAnswerPollResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c5bb13e2c778488f, []int{11}
}
func (m *MsgAnswerPollResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAnswerPollResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAnswerPollResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAnswerPollResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAnswerPollResponse.Merge(m, src)
}
func (m *MsgAnswerPollResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAnswerPollResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAnswerPollResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAnswerPollResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreatePost)(nil), "desmos.posts.v3.MsgCreatePost")
	proto.RegisterType((*MsgCreatePostResponse)(nil), "desmos.posts.v3.MsgCreatePostResponse")
	proto.RegisterType((*MsgEditPost)(nil), "desmos.posts.v3.MsgEditPost")
	proto.RegisterType((*MsgEditPostResponse)(nil), "desmos.posts.v3.MsgEditPostResponse")
	proto.RegisterType((*MsgDeletePost)(nil), "desmos.posts.v3.MsgDeletePost")
	proto.RegisterType((*MsgDeletePostResponse)(nil), "desmos.posts.v3.MsgDeletePostResponse")
	proto.RegisterType((*MsgAddPostAttachment)(nil), "desmos.posts.v3.MsgAddPostAttachment")
	proto.RegisterType((*MsgAddPostAttachmentResponse)(nil), "desmos.posts.v3.MsgAddPostAttachmentResponse")
	proto.RegisterType((*MsgRemovePostAttachment)(nil), "desmos.posts.v3.MsgRemovePostAttachment")
	proto.RegisterType((*MsgRemovePostAttachmentResponse)(nil), "desmos.posts.v3.MsgRemovePostAttachmentResponse")
	proto.RegisterType((*MsgAnswerPoll)(nil), "desmos.posts.v3.MsgAnswerPoll")
	proto.RegisterType((*MsgAnswerPollResponse)(nil), "desmos.posts.v3.MsgAnswerPollResponse")
}

func init() { proto.RegisterFile("desmos/posts/v3/msgs.proto", fileDescriptor_c5bb13e2c778488f) }

var fileDescriptor_c5bb13e2c778488f = []byte{
	// 1109 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0xe2, 0x46,
	0x14, 0x8f, 0x81, 0x90, 0x30, 0x04, 0xd8, 0x78, 0xd9, 0x86, 0x20, 0x8a, 0xe9, 0x74, 0x5b, 0x11,
	0xa9, 0x31, 0x15, 0x69, 0x55, 0xa9, 0x3d, 0xe1, 0x24, 0x52, 0xa9, 0x44, 0x15, 0x39, 0xd9, 0x4b,
	0x2f, 0xc8, 0xe0, 0x59, 0xc7, 0x95, 0xf1, 0x20, 0xcf, 0x84, 0xc2, 0xb7, 0xd8, 0x7e, 0x8b, 0x5e,
	0x2b, 0xad, 0xaa, 0xaa, 0xe7, 0x1e, 0x56, 0x55, 0x0f, 0x7b, 0xec, 0xc9, 0xad, 0xc8, 0x37, 0xe0,
	0x13, 0x54, 0x1e, 0x8f, 0xb1, 0xc1, 0xde, 0x2c, 0xdb, 0xa6, 0xda, 0xde, 0x98, 0xf7, 0x7e, 0xef,
	0xcf, 0xbc, 0xdf, 0x7b, 0xcf, 0x03, 0xa8, 0xea, 0x88, 0x8c, 0x30, 0x69, 0x8d, 0x31, 0xa1, 0xa4,
	0x35, 0x39, 0x69, 0x8d, 0x88, 0x41, 0xe4, 0xb1, 0x83, 0x29, 0x16, 0x4b, 0xbe, 0x4e, 0x66, 0x3a,
	0x79, 0x72, 0x52, 0x2d, 0x1b, 0xd8, 0xc0, 0x4c, 0xd7, 0xf2, 0x7e, 0xf9, 0xb0, 0xea, 0xa1, 0x81,
	0xb1, 0x61, 0xa1, 0x16, 0x3b, 0x0d, 0x6e, 0x9e, 0xb6, 0x34, 0x7b, 0xc6, 0x55, 0xd2, 0xba, 0x8a,
	0x9a, 0x23, 0x44, 0xa8, 0x36, 0x1a, 0x07, 0xb6, 0x43, 0xec, 0x85, 0xe8, 0xfb, 0x4e, 0xfd, 0x03,
	0x57, 0xd5, 0x62, 0x99, 0x61, 0x1d, 0x59, 0x5c, 0x0b, 0x7f, 0xc9, 0x82, 0x42, 0x8f, 0x18, 0xa7,
	0x0e, 0xd2, 0x28, 0xba, 0xc0, 0x84, 0x8a, 0xe7, 0x20, 0x4f, 0x6e, 0x06, 0x64, 0xac, 0x0d, 0x51,
	0xdf, 0xd4, 0x2b, 0x42, 0x43, 0x68, 0x66, 0x94, 0xc7, 0x73, 0x57, 0x02, 0x97, 0x5c, 0xdc, 0x3d,
	0x5b, 0xb8, 0x92, 0x38, 0xd3, 0x46, 0xd6, 0xe7, 0x30, 0x02, 0x85, 0x2a, 0x08, 0x4e, 0x5d, 0x5d,
	0xec, 0x00, 0x40, 0xd0, 0x90, 0x9a, 0xd8, 0xf6, 0xbc, 0xa4, 0x1a, 0x42, 0xb3, 0xa0, 0xc0, 0xb9,
	0x2b, 0xe5, 0x2e, 0x7d, 0x29, 0x73, 0xb2, 0xcf, 0x9d, 0x2c, 0x81, 0x50, 0xcd, 0xf1, 0x43, 0x57,
	0xf7, 0x32, 0x41, 0x53, 0x8a, 0x1c, 0x5b, 0xb3, 0x3c, 0x1f, 0xe9, 0x86, 0xd0, 0xcc, 0xf9, 0x99,
	0x9c, 0x73, 0x71, 0x34, 0x93, 0x08, 0x14, 0xaa, 0x20, 0x38, 0x75, 0x75, 0xf1, 0x7d, 0x90, 0xa1,
	0x68, 0x4a, 0x2b, 0x19, 0x66, 0x5f, 0x5a, 0xb8, 0x52, 0xde, 0xb7, 0xf0, 0xa4, 0x50, 0x65, 0x4a,
	0xf1, 0x2b, 0xb0, 0x8b, 0x6c, 0x6a, 0x52, 0x13, 0x91, 0xca, 0x76, 0x43, 0x68, 0xe6, 0xdb, 0x87,
	0xf2, 0x1a, 0x6d, 0xf2, 0x39, 0x07, 0x28, 0x0f, 0x17, 0xae, 0x54, 0xe2, 0x51, 0xb9, 0x0c, 0xaa,
	0x4b, 0x7b, 0x16, 0x50, 0x33, 0x48, 0x25, 0xdb, 0x48, 0xaf, 0x05, 0xd4, 0x0c, 0xe2, 0x05, 0xd4,
	0x0c, 0x22, 0x12, 0x90, 0xd7, 0x28, 0xd5, 0x86, 0xd7, 0x23, 0x64, 0x53, 0x52, 0xd9, 0x69, 0xa4,
	0x9b, 0xf9, 0x76, 0x59, 0xf6, 0x89, 0x96, 0x03, 0xa2, 0xe5, 0x8e, 0x3d, 0x53, 0xbe, 0x08, 0x2f,
	0x19, 0x31, 0x81, 0xbf, 0x3d, 0x3f, 0x7e, 0x6f, 0x3d, 0xc5, 0xce, 0x52, 0x7f, 0x8a, 0x6d, 0x8a,
	0x6c, 0xaa, 0x46, 0xa3, 0x88, 0x47, 0x20, 0xab, 0xdd, 0xd0, 0x6b, 0xec, 0x54, 0x76, 0x59, 0x31,
	0xf6, 0x17, 0xae, 0x54, 0xe0, 0x9e, 0x99, 0x1c, 0xaa, 0x1c, 0x20, 0x3e, 0x01, 0xa5, 0x21, 0xb6,
	0x27, 0xc8, 0x21, 0x5a, 0x40, 0x62, 0x8e, 0xb5, 0xc2, 0x47, 0x73, 0x57, 0x2a, 0x9e, 0x46, 0x54,
	0x8c, 0x84, 0x77, 0x7c, 0x2f, 0x6b, 0x26, 0x50, 0x2d, 0x46, 0x25, 0x5d, 0x5d, 0xec, 0x83, 0xa2,
	0x83, 0xc6, 0xd6, 0xac, 0x4f, 0x10, 0xa5, 0xa6, 0x6d, 0x90, 0x0a, 0x68, 0x08, 0xcd, 0x62, 0xfb,
	0xdd, 0x58, 0xb5, 0x55, 0x0f, 0x76, 0xe9, 0xa3, 0x94, 0xc3, 0x85, 0x2b, 0x3d, 0xf2, 0x43, 0xac,
	0x9a, 0x43, 0xb5, 0xe0, 0x44, 0x80, 0x44, 0xfc, 0x16, 0x3c, 0x70, 0xd0, 0x53, 0xe4, 0x20, 0x7b,
	0x88, 0xf4, 0x3e, 0xf3, 0x56, 0xc9, 0xb3, 0xe2, 0xd6, 0x63, 0x21, 0xbc, 0x7e, 0x57, 0x03, 0xb0,
	0x22, 0xbd, 0x70, 0xa5, 0xad, 0x85, 0x2b, 0x1d, 0x04, 0x71, 0x56, 0xbd, 0x40, 0xb5, 0x14, 0x8a,
	0x2e, 0x98, 0xe4, 0x47, 0x01, 0x3c, 0x5a, 0x19, 0x1e, 0x15, 0x91, 0x31, 0xb6, 0x09, 0x12, 0x3f,
	0x05, 0x3b, 0x9e, 0x51, 0x38, 0x40, 0xb5, 0xb9, 0x2b, 0x65, 0x3d, 0x08, 0xab, 0x56, 0xd1, 0x0f,
	0xc1, 0x21, 0x50, 0xcd, 0x7a, 0xbf, 0xba, 0xba, 0xa8, 0x81, 0xc2, 0xd0, 0x73, 0xe6, 0x55, 0x4f,
	0xd7, 0x28, 0x62, 0x73, 0x93, 0x6f, 0x57, 0x63, 0x6d, 0x71, 0x15, 0xcc, 0xbf, 0xd2, 0xe0, 0x59,
	0x97, 0x39, 0x01, 0x51, 0x73, 0xf8, 0xec, 0x4f, 0x49, 0x50, 0xf7, 0x02, 0xd9, 0x99, 0x27, 0xfa,
	0x3d, 0x05, 0xf2, 0x3d, 0x62, 0x9c, 0xeb, 0x26, 0xbd, 0xcf, 0x71, 0x8f, 0x5c, 0x38, 0xf5, 0x06,
	0x17, 0x0e, 0x66, 0x33, 0xbd, 0xe9, 0x6c, 0x66, 0xee, 0x69, 0x36, 0xb7, 0xef, 0x9a, 0xcd, 0x23,
	0x90, 0x45, 0xba, 0x49, 0xb1, 0x53, 0xc9, 0xae, 0x8f, 0x89, 0x2f, 0x87, 0x2a, 0x07, 0x40, 0x0b,
	0x3c, 0x8c, 0x54, 0x73, 0xc9, 0xff, 0x13, 0x90, 0xf3, 0x00, 0x3e, 0x89, 0xc2, 0x6b, 0x49, 0xac,
	0x71, 0x12, 0x1f, 0x84, 0x41, 0x22, 0x04, 0xee, 0x7a, 0x67, 0x46, 0xde, 0xcf, 0x02, 0xdb, 0xd6,
	0x67, 0xc8, 0x42, 0xf7, 0xbb, 0xad, 0xff, 0x21, 0x7d, 0x47, 0x20, 0x4b, 0x4c, 0xc3, 0x46, 0x0e,
	0x27, 0x30, 0x52, 0x28, 0x5f, 0x0e, 0x55, 0x0e, 0x80, 0x07, 0x6c, 0x54, 0xc2, 0xcc, 0x83, 0x52,
	0xc1, 0x1f, 0x52, 0xa0, 0xdc, 0x23, 0x46, 0x47, 0x67, 0x43, 0x15, 0x2e, 0xb0, 0xb7, 0x7c, 0x35,
	0x03, 0xec, 0x0c, 0xfd, 0x15, 0xca, 0xee, 0xf6, 0xaa, 0xdd, 0xfc, 0x59, 0xe8, 0x82, 0xc3, 0x37,
	0xdc, 0xcb, 0x81, 0xf7, 0x48, 0xb3, 0x65, 0x5e, 0xd7, 0x6c, 0xbf, 0x0a, 0xa0, 0x96, 0x54, 0xaa,
	0x65, 0xdb, 0xf5, 0x40, 0x21, 0x5c, 0xf7, 0x41, 0xd1, 0x0a, 0x4a, 0x73, 0xee, 0x4a, 0x7b, 0x21,
	0x9c, 0xdd, 0xbb, 0xbc, 0xfe, 0x41, 0x61, 0xb7, 0xdf, 0x0b, 0xcf, 0x5d, 0x7d, 0xb5, 0x8b, 0x53,
	0xf7, 0xd6, 0xc5, 0xdf, 0xa7, 0xc0, 0x41, 0x8f, 0x18, 0x2a, 0x1a, 0xe1, 0x09, 0xfa, 0x5f, 0x91,
	0x1e, 0xab, 0x5f, 0xfa, 0x5f, 0xd5, 0xef, 0x0d, 0xa8, 0x9d, 0x02, 0xe9, 0x15, 0x25, 0xf9, 0xaf,
	0x77, 0xca, 0xf3, 0x14, 0xdb, 0x29, 0x1d, 0x9b, 0x7c, 0x87, 0x9c, 0x0b, 0x6c, 0x59, 0x6f, 0x99,
	0x03, 0x66, 0x66, 0x59, 0x61, 0xf5, 0xb9, 0x99, 0x65, 0xad, 0x9a, 0x59, 0x56, 0x60, 0x66, 0x79,
	0xaf, 0xbc, 0x53, 0x50, 0xd2, 0xd8, 0x15, 0x48, 0xdf, 0xb4, 0x75, 0x34, 0x65, 0xdf, 0x8a, 0x74,
	0xb3, 0xa0, 0x54, 0xc3, 0xd7, 0xc9, 0x1a, 0x00, 0xaa, 0x45, 0x2e, 0xe9, 0xfa, 0x82, 0xc8, 0x3e,
	0xdb, 0xde, 0x6c, 0x9f, 0x85, 0x55, 0x0b, 0x68, 0x6a, 0xff, 0x94, 0x01, 0xe9, 0x1e, 0x31, 0xc4,
	0x2b, 0x00, 0x22, 0xaf, 0xea, 0xf8, 0xe3, 0x63, 0xe5, 0xe1, 0x50, 0xfd, 0xf0, 0x6e, 0xfd, 0xb2,
	0x09, 0xbe, 0x06, 0xbb, 0xcb, 0x4f, 0x77, 0x2d, 0xc9, 0x26, 0xd0, 0x56, 0x1f, 0xdf, 0xa5, 0x5d,
	0xfa, 0xbb, 0x02, 0x20, 0xf2, 0x35, 0x49, 0xcc, 0x32, 0xd4, 0x27, 0x67, 0x19, 0xdf, 0xe9, 0xa2,
	0x09, 0xf6, 0xe3, 0xfb, 0xfc, 0x83, 0x24, 0xe3, 0x18, 0xac, 0x7a, 0xbc, 0x11, 0x6c, 0x19, 0xca,
	0x01, 0xe5, 0xc4, 0x45, 0xd2, 0x4c, 0x72, 0x93, 0x84, 0xac, 0x7e, 0xbc, 0x29, 0x32, 0x5a, 0xb4,
	0xc8, 0xb8, 0x24, 0x16, 0x2d, 0xd4, 0x27, 0x17, 0x2d, 0xde, 0x38, 0xca, 0x97, 0x2f, 0xe6, 0x75,
	0xe1, 0xe5, 0xbc, 0x2e, 0xfc, 0x35, 0xaf, 0x0b, 0xcf, 0x6e, 0xeb, 0x5b, 0x2f, 0x6f, 0xeb, 0x5b,
	0x7f, 0xdc, 0xd6, 0xb7, 0xbe, 0x91, 0x0d, 0x93, 0x5e, 0xdf, 0x0c, 0xe4, 0x21, 0x1e, 0xb5, 0x7c,
	0x5f, 0xc7, 0x96, 0x36, 0x20, 0xfc, 0x77, 0x6b, 0xf2, 0x49, 0x6b, 0xca, 0xff, 0xde, 0xd1, 0xd9,
	0x18, 0x91, 0x41, 0x96, 0xad, 0x83, 0x93, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x2f, 0xbe,
	0x47, 0x95, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreatePost allows to create a new post
	CreatePost(ctx context.Context, in *MsgCreatePost, opts ...grpc.CallOption) (*MsgCreatePostResponse, error)
	// EditPost allows to edit an existing post
	EditPost(ctx context.Context, in *MsgEditPost, opts ...grpc.CallOption) (*MsgEditPostResponse, error)
	// DeletePost allows to delete an existing post
	DeletePost(ctx context.Context, in *MsgDeletePost, opts ...grpc.CallOption) (*MsgDeletePostResponse, error)
	// AddPostAttachment allows to add a new attachment to a post
	AddPostAttachment(ctx context.Context, in *MsgAddPostAttachment, opts ...grpc.CallOption) (*MsgAddPostAttachmentResponse, error)
	// RemovePostAttachment allows to remove an attachment from a post
	RemovePostAttachment(ctx context.Context, in *MsgRemovePostAttachment, opts ...grpc.CallOption) (*MsgRemovePostAttachmentResponse, error)
	// AnswerPoll allows to answer a post poll
	AnswerPoll(ctx context.Context, in *MsgAnswerPoll, opts ...grpc.CallOption) (*MsgAnswerPollResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreatePost(ctx context.Context, in *MsgCreatePost, opts ...grpc.CallOption) (*MsgCreatePostResponse, error) {
	out := new(MsgCreatePostResponse)
	err := c.cc.Invoke(ctx, "/desmos.posts.v3.Msg/CreatePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) EditPost(ctx context.Context, in *MsgEditPost, opts ...grpc.CallOption) (*MsgEditPostResponse, error) {
	out := new(MsgEditPostResponse)
	err := c.cc.Invoke(ctx, "/desmos.posts.v3.Msg/EditPost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeletePost(ctx context.Context, in *MsgDeletePost, opts ...grpc.CallOption) (*MsgDeletePostResponse, error) {
	out := new(MsgDeletePostResponse)
	err := c.cc.Invoke(ctx, "/desmos.posts.v3.Msg/DeletePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddPostAttachment(ctx context.Context, in *MsgAddPostAttachment, opts ...grpc.CallOption) (*MsgAddPostAttachmentResponse, error) {
	out := new(MsgAddPostAttachmentResponse)
	err := c.cc.Invoke(ctx, "/desmos.posts.v3.Msg/AddPostAttachment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemovePostAttachment(ctx context.Context, in *MsgRemovePostAttachment, opts ...grpc.CallOption) (*MsgRemovePostAttachmentResponse, error) {
	out := new(MsgRemovePostAttachmentResponse)
	err := c.cc.Invoke(ctx, "/desmos.posts.v3.Msg/RemovePostAttachment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AnswerPoll(ctx context.Context, in *MsgAnswerPoll, opts ...grpc.CallOption) (*MsgAnswerPollResponse, error) {
	out := new(MsgAnswerPollResponse)
	err := c.cc.Invoke(ctx, "/desmos.posts.v3.Msg/AnswerPoll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreatePost allows to create a new post
	CreatePost(context.Context, *MsgCreatePost) (*MsgCreatePostResponse, error)
	// EditPost allows to edit an existing post
	EditPost(context.Context, *MsgEditPost) (*MsgEditPostResponse, error)
	// DeletePost allows to delete an existing post
	DeletePost(context.Context, *MsgDeletePost) (*MsgDeletePostResponse, error)
	// AddPostAttachment allows to add a new attachment to a post
	AddPostAttachment(context.Context, *MsgAddPostAttachment) (*MsgAddPostAttachmentResponse, error)
	// RemovePostAttachment allows to remove an attachment from a post
	RemovePostAttachment(context.Context, *MsgRemovePostAttachment) (*MsgRemovePostAttachmentResponse, error)
	// AnswerPoll allows to answer a post poll
	AnswerPoll(context.Context, *MsgAnswerPoll) (*MsgAnswerPollResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreatePost(ctx context.Context, req *MsgCreatePost) (*MsgCreatePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}
func (*UnimplementedMsgServer) EditPost(ctx context.Context, req *MsgEditPost) (*MsgEditPostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditPost not implemented")
}
func (*UnimplementedMsgServer) DeletePost(ctx context.Context, req *MsgDeletePost) (*MsgDeletePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}
func (*UnimplementedMsgServer) AddPostAttachment(ctx context.Context, req *MsgAddPostAttachment) (*MsgAddPostAttachmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPostAttachment not implemented")
}
func (*UnimplementedMsgServer) RemovePostAttachment(ctx context.Context, req *MsgRemovePostAttachment) (*MsgRemovePostAttachmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePostAttachment not implemented")
}
func (*UnimplementedMsgServer) AnswerPoll(ctx context.Context, req *MsgAnswerPoll) (*MsgAnswerPollResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnswerPoll not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreatePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.posts.v3.Msg/CreatePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreatePost(ctx, req.(*MsgCreatePost))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_EditPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEditPost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).EditPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.posts.v3.Msg/EditPost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).EditPost(ctx, req.(*MsgEditPost))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeletePost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeletePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.posts.v3.Msg/DeletePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeletePost(ctx, req.(*MsgDeletePost))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddPostAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddPostAttachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddPostAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.posts.v3.Msg/AddPostAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddPostAttachment(ctx, req.(*MsgAddPostAttachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemovePostAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemovePostAttachment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemovePostAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.posts.v3.Msg/RemovePostAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemovePostAttachment(ctx, req.(*MsgRemovePostAttachment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AnswerPoll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAnswerPoll)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AnswerPoll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/desmos.posts.v3.Msg/AnswerPoll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AnswerPoll(ctx, req.(*MsgAnswerPoll))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "desmos.posts.v3.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePost",
			Handler:    _Msg_CreatePost_Handler,
		},
		{
			MethodName: "EditPost",
			Handler:    _Msg_EditPost_Handler,
		},
		{
			MethodName: "DeletePost",
			Handler:    _Msg_DeletePost_Handler,
		},
		{
			MethodName: "AddPostAttachment",
			Handler:    _Msg_AddPostAttachment_Handler,
		},
		{
			MethodName: "RemovePostAttachment",
			Handler:    _Msg_RemovePostAttachment_Handler,
		},
		{
			MethodName: "AnswerPoll",
			Handler:    _Msg_AnswerPoll_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "desmos/posts/v3/msgs.proto",
}

func (m *MsgCreatePost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReferencedPosts) > 0 {
		for iNdEx := len(m.ReferencedPosts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReferencedPosts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ReplySettings != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.ReplySettings))
		i--
		dAtA[i] = 0x50
	}
	if m.ConversationID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.ConversationID))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Attachments) > 0 {
		for iNdEx := len(m.Attachments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attachments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Entities != nil {
		{
			size, err := m.Entities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SectionID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SectionID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreatePostResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePostResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePostResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreationDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreationDate):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintMsgs(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if m.PostID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgEditPost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditPost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditPost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Editor) > 0 {
		i -= len(m.Editor)
		copy(dAtA[i:], m.Editor)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Editor)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintMsgs(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Entities != nil {
		{
			size, err := m.Entities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PostID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgEditPostResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditPostResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditPostResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EditDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EditDate):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintMsgs(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgDeletePost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeletePost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeletePost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PostID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeletePostResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeletePostResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeletePostResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddPostAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPostAttachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddPostAttachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Editor) > 0 {
		i -= len(m.Editor)
		copy(dAtA[i:], m.Editor)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Editor)))
		i--
		dAtA[i] = 0x22
	}
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PostID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddPostAttachmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddPostAttachmentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddPostAttachmentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EditDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EditDate):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintMsgs(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x12
	if m.AttachmentID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.AttachmentID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemovePostAttachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemovePostAttachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemovePostAttachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Editor) > 0 {
		i -= len(m.Editor)
		copy(dAtA[i:], m.Editor)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Editor)))
		i--
		dAtA[i] = 0x22
	}
	if m.AttachmentID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.AttachmentID))
		i--
		dAtA[i] = 0x18
	}
	if m.PostID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemovePostAttachmentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemovePostAttachmentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemovePostAttachmentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EditDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EditDate):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintMsgs(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgAnswerPoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAnswerPoll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAnswerPoll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintMsgs(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AnswersIndexes) > 0 {
		dAtA9 := make([]byte, len(m.AnswersIndexes)*10)
		var j8 int
		for _, num := range m.AnswersIndexes {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintMsgs(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x22
	}
	if m.PollID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PollID))
		i--
		dAtA[i] = 0x18
	}
	if m.PostID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.PostID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubspaceID != 0 {
		i = encodeVarintMsgs(dAtA, i, uint64(m.SubspaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAnswerPollResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAnswerPollResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAnswerPollResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintMsgs(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreatePost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovMsgs(uint64(m.SubspaceID))
	}
	if m.SectionID != 0 {
		n += 1 + sovMsgs(uint64(m.SectionID))
	}
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Entities != nil {
		l = m.Entities.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.ConversationID != 0 {
		n += 1 + sovMsgs(uint64(m.ConversationID))
	}
	if m.ReplySettings != 0 {
		n += 1 + sovMsgs(uint64(m.ReplySettings))
	}
	if len(m.ReferencedPosts) > 0 {
		for _, e := range m.ReferencedPosts {
			l = e.Size()
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	return n
}

func (m *MsgCreatePostResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PostID != 0 {
		n += 1 + sovMsgs(uint64(m.PostID))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreationDate)
	n += 1 + l + sovMsgs(uint64(l))
	return n
}

func (m *MsgEditPost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovMsgs(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovMsgs(uint64(m.PostID))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	if m.Entities != nil {
		l = m.Entities.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovMsgs(uint64(l))
		}
	}
	l = len(m.Editor)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgEditPostResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EditDate)
	n += 1 + l + sovMsgs(uint64(l))
	return n
}

func (m *MsgDeletePost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovMsgs(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovMsgs(uint64(m.PostID))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgDeletePostResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddPostAttachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovMsgs(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovMsgs(uint64(m.PostID))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovMsgs(uint64(l))
	}
	l = len(m.Editor)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgAddPostAttachmentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttachmentID != 0 {
		n += 1 + sovMsgs(uint64(m.AttachmentID))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EditDate)
	n += 1 + l + sovMsgs(uint64(l))
	return n
}

func (m *MsgRemovePostAttachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovMsgs(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovMsgs(uint64(m.PostID))
	}
	if m.AttachmentID != 0 {
		n += 1 + sovMsgs(uint64(m.AttachmentID))
	}
	l = len(m.Editor)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgRemovePostAttachmentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EditDate)
	n += 1 + l + sovMsgs(uint64(l))
	return n
}

func (m *MsgAnswerPoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubspaceID != 0 {
		n += 1 + sovMsgs(uint64(m.SubspaceID))
	}
	if m.PostID != 0 {
		n += 1 + sovMsgs(uint64(m.PostID))
	}
	if m.PollID != 0 {
		n += 1 + sovMsgs(uint64(m.PollID))
	}
	if len(m.AnswersIndexes) > 0 {
		l = 0
		for _, e := range m.AnswersIndexes {
			l += sovMsgs(uint64(e))
		}
		n += 1 + sovMsgs(uint64(l)) + l
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovMsgs(uint64(l))
	}
	return n
}

func (m *MsgAnswerPollResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovMsgs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgs(x uint64) (n int) {
	return sovMsgs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreatePost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionID", wireType)
			}
			m.SectionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entities == nil {
				m.Entities = &Entities{}
			}
			if err := m.Entities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &types.Any{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationID", wireType)
			}
			m.ConversationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConversationID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplySettings", wireType)
			}
			m.ReplySettings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplySettings |= ReplySetting(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedPosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferencedPosts = append(m.ReferencedPosts, PostReference{})
			if err := m.ReferencedPosts[len(m.ReferencedPosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreatePostResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePostResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePostResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreationDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditPost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditPost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditPost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entities == nil {
				m.Entities = &Entities{}
			}
			if err := m.Entities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Editor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Editor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditPostResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditPostResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditPostResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EditDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeletePost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeletePost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeletePost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeletePostResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeletePostResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeletePostResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPostAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPostAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPostAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &types.Any{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Editor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Editor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddPostAttachmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddPostAttachmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddPostAttachmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentID", wireType)
			}
			m.AttachmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttachmentID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EditDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemovePostAttachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemovePostAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemovePostAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentID", wireType)
			}
			m.AttachmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttachmentID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Editor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Editor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemovePostAttachmentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemovePostAttachmentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemovePostAttachmentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EditDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAnswerPoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAnswerPoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAnswerPoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubspaceID", wireType)
			}
			m.SubspaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubspaceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostID", wireType)
			}
			m.PostID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PostID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollID", wireType)
			}
			m.PollID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AnswersIndexes = append(m.AnswersIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AnswersIndexes) == 0 {
					m.AnswersIndexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AnswersIndexes = append(m.AnswersIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswersIndexes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAnswerPollResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAnswerPollResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAnswerPollResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMsgs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgs = fmt.Errorf("proto: unexpected end of group")
)
