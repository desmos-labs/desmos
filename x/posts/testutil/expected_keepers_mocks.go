// Code generated by MockGen. DO NOT EDIT.
// Source: types/expected_keepers.go

// Package testutil is a generated GoMock package.
package testutil

import (
	reflect "reflect"

	types "github.com/cosmos/cosmos-sdk/types"
	types0 "github.com/desmos-labs/desmos/v4/x/subspaces/types"
	gomock "github.com/golang/mock/gomock"
)

// MockProfilesKeeper is a mock of ProfilesKeeper interface.
type MockProfilesKeeper struct {
	ctrl     *gomock.Controller
	recorder *MockProfilesKeeperMockRecorder
}

// MockProfilesKeeperMockRecorder is the mock recorder for MockProfilesKeeper.
type MockProfilesKeeperMockRecorder struct {
	mock *MockProfilesKeeper
}

// NewMockProfilesKeeper creates a new mock instance.
func NewMockProfilesKeeper(ctrl *gomock.Controller) *MockProfilesKeeper {
	mock := &MockProfilesKeeper{ctrl: ctrl}
	mock.recorder = &MockProfilesKeeperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProfilesKeeper) EXPECT() *MockProfilesKeeperMockRecorder {
	return m.recorder
}

// HasProfile mocks base method.
func (m *MockProfilesKeeper) HasProfile(ctx types.Context, user string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasProfile", ctx, user)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasProfile indicates an expected call of HasProfile.
func (mr *MockProfilesKeeperMockRecorder) HasProfile(ctx, user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasProfile", reflect.TypeOf((*MockProfilesKeeper)(nil).HasProfile), ctx, user)
}

// MockSubspacesKeeper is a mock of SubspacesKeeper interface.
type MockSubspacesKeeper struct {
	ctrl     *gomock.Controller
	recorder *MockSubspacesKeeperMockRecorder
}

// MockSubspacesKeeperMockRecorder is the mock recorder for MockSubspacesKeeper.
type MockSubspacesKeeperMockRecorder struct {
	mock *MockSubspacesKeeper
}

// NewMockSubspacesKeeper creates a new mock instance.
func NewMockSubspacesKeeper(ctrl *gomock.Controller) *MockSubspacesKeeper {
	mock := &MockSubspacesKeeper{ctrl: ctrl}
	mock.recorder = &MockSubspacesKeeperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubspacesKeeper) EXPECT() *MockSubspacesKeeperMockRecorder {
	return m.recorder
}

// HasPermission mocks base method.
func (m *MockSubspacesKeeper) HasPermission(ctx types.Context, subspaceID uint64, sectionID uint32, user string, permission types0.Permission) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasPermission", ctx, subspaceID, sectionID, user, permission)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasPermission indicates an expected call of HasPermission.
func (mr *MockSubspacesKeeperMockRecorder) HasPermission(ctx, subspaceID, sectionID, user, permission interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasPermission", reflect.TypeOf((*MockSubspacesKeeper)(nil).HasPermission), ctx, subspaceID, sectionID, user, permission)
}

// HasSection mocks base method.
func (m *MockSubspacesKeeper) HasSection(ctx types.Context, subspaceID uint64, sectionID uint32) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSection", ctx, subspaceID, sectionID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSection indicates an expected call of HasSection.
func (mr *MockSubspacesKeeperMockRecorder) HasSection(ctx, subspaceID, sectionID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSection", reflect.TypeOf((*MockSubspacesKeeper)(nil).HasSection), ctx, subspaceID, sectionID)
}

// HasSubspace mocks base method.
func (m *MockSubspacesKeeper) HasSubspace(ctx types.Context, subspaceID uint64) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSubspace", ctx, subspaceID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSubspace indicates an expected call of HasSubspace.
func (mr *MockSubspacesKeeperMockRecorder) HasSubspace(ctx, subspaceID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSubspace", reflect.TypeOf((*MockSubspacesKeeper)(nil).HasSubspace), ctx, subspaceID)
}

// IterateSubspaces mocks base method.
func (m *MockSubspacesKeeper) IterateSubspaces(ctx types.Context, fn func(types0.Subspace) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "IterateSubspaces", ctx, fn)
}

// IterateSubspaces indicates an expected call of IterateSubspaces.
func (mr *MockSubspacesKeeperMockRecorder) IterateSubspaces(ctx, fn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IterateSubspaces", reflect.TypeOf((*MockSubspacesKeeper)(nil).IterateSubspaces), ctx, fn)
}

// MockRelationshipsKeeper is a mock of RelationshipsKeeper interface.
type MockRelationshipsKeeper struct {
	ctrl     *gomock.Controller
	recorder *MockRelationshipsKeeperMockRecorder
}

// MockRelationshipsKeeperMockRecorder is the mock recorder for MockRelationshipsKeeper.
type MockRelationshipsKeeperMockRecorder struct {
	mock *MockRelationshipsKeeper
}

// NewMockRelationshipsKeeper creates a new mock instance.
func NewMockRelationshipsKeeper(ctrl *gomock.Controller) *MockRelationshipsKeeper {
	mock := &MockRelationshipsKeeper{ctrl: ctrl}
	mock.recorder = &MockRelationshipsKeeperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRelationshipsKeeper) EXPECT() *MockRelationshipsKeeperMockRecorder {
	return m.recorder
}

// HasRelationship mocks base method.
func (m *MockRelationshipsKeeper) HasRelationship(ctx types.Context, user, counterparty string, subspaceID uint64) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasRelationship", ctx, user, counterparty, subspaceID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasRelationship indicates an expected call of HasRelationship.
func (mr *MockRelationshipsKeeperMockRecorder) HasRelationship(ctx, user, counterparty, subspaceID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasRelationship", reflect.TypeOf((*MockRelationshipsKeeper)(nil).HasRelationship), ctx, user, counterparty, subspaceID)
}

// HasUserBlocked mocks base method.
func (m *MockRelationshipsKeeper) HasUserBlocked(ctx types.Context, blocker, user string, subspaceID uint64) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasUserBlocked", ctx, blocker, user, subspaceID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasUserBlocked indicates an expected call of HasUserBlocked.
func (mr *MockRelationshipsKeeperMockRecorder) HasUserBlocked(ctx, blocker, user, subspaceID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasUserBlocked", reflect.TypeOf((*MockRelationshipsKeeper)(nil).HasUserBlocked), ctx, blocker, user, subspaceID)
}
