// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: desmos/ibc/applications/profiles/v1/models.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/x/ibc/core/02-client/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// State defines if a connection is in the following states:
// STARTED, ERRORED, SUCCESSFUL, TIMED_OUT
type State int32

const (
	// Default State
	UNINITIALIZED State = 0
	// A connection has just been started
	STARTED State = 1
	// A connection has errored during the verification
	ERROR State = 2
	// A connection has been verified successfully
	SUCCESS State = 3
	// A connection has timed out during the verification
	TIMEOUT State = 4
)

var State_name = map[int32]string{
	0: "STATE_UNINITIALIZED_UNSPECIFIED",
	1: "STATE_STARTED",
	2: "STATE_ERROR",
	3: "STATE_SUCCESS",
	4: "STATE_TIMED_OUT",
}

var State_value = map[string]int32{
	"STATE_UNINITIALIZED_UNSPECIFIED": 0,
	"STATE_STARTED":                   1,
	"STATE_ERROR":                     2,
	"STATE_SUCCESS":                   3,
	"STATE_TIMED_OUT":                 4,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}

func (State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{0}
}

// ApplicationData contains the data of a generic centralized application
type ApplicationData struct {
	// The application name (eg. Twitter, GitHub, etc)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Username on the application (eg. Twitter tag, GitHub profile, etc)
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *ApplicationData) Reset()         { *m = ApplicationData{} }
func (m *ApplicationData) String() string { return proto.CompactTextString(m) }
func (*ApplicationData) ProtoMessage()    {}
func (*ApplicationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{0}
}
func (m *ApplicationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationData.Merge(m, src)
}
func (m *ApplicationData) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationData) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationData.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationData proto.InternalMessageInfo

func (m *ApplicationData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApplicationData) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

// VerificationData contains the data of a single verification
type VerificationData struct {
	// The method uses to verify the social account ownership (eg. tweet, gist, etc.)
	Method string `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty" yaml:"method"`
	// The value used to verify the social account ownership (eg. Twitter tweet id, GitHub gist id, etc)
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" yaml:"value"`
}

func (m *VerificationData) Reset()         { *m = VerificationData{} }
func (m *VerificationData) String() string { return proto.CompactTextString(m) }
func (*VerificationData) ProtoMessage()    {}
func (*VerificationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{1}
}
func (m *VerificationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationData.Merge(m, src)
}
func (m *VerificationData) XXX_Size() int {
	return m.Size()
}
func (m *VerificationData) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationData.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationData proto.InternalMessageInfo

func (m *VerificationData) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *VerificationData) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Connection contains the data of a centralized social network connection
type Connection struct {
	// User that has created the connection
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// Application to which the user has connected
	Application *ApplicationData `protobuf:"bytes,2,opt,name=application,proto3" json:"application,omitempty"`
	// Data used to verify the connection
	Verification *VerificationData `protobuf:"bytes,3,opt,name=verification,proto3" json:"verification,omitempty"`
	// State of the connection
	State State `protobuf:"varint,4,opt,name=state,proto3,enum=desmos.ibc.applications.profiles.v1.State" json:"state,omitempty"`
	// Data coming from the result of the verification.
	// Only available when the state is STATE_SUCCESS
	Result *Result `protobuf:"bytes,5,opt,name=result,proto3" json:"result,omitempty"`
	// Creation time of the connection
	CreationTime time.Time `protobuf:"bytes,6,opt,name=creation_time,json=creationTime,proto3,stdtime" json:"creation_time"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{2}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

func (m *Connection) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Connection) GetApplication() *ApplicationData {
	if m != nil {
		return m.Application
	}
	return nil
}

func (m *Connection) GetVerification() *VerificationData {
	if m != nil {
		return m.Verification
	}
	return nil
}

func (m *Connection) GetState() State {
	if m != nil {
		return m.State
	}
	return UNINITIALIZED
}

func (m *Connection) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Connection) GetCreationTime() time.Time {
	if m != nil {
		return m.CreationTime
	}
	return time.Time{}
}

// Result represents a verification result
type Result struct {
	// sum is the oneof that specifies whether this represents a success or failure result
	//
	// Types that are valid to be assigned to Sum:
	//	*Result_Success_
	//	*Result_Failed_
	Sum isResult_Sum `protobuf_oneof:"sum"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{3}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

type isResult_Sum interface {
	isResult_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Result_Success_ struct {
	Success *Result_Success `protobuf:"bytes,1,opt,name=success,proto3,oneof" json:"success,omitempty"`
}
type Result_Failed_ struct {
	Failed *Result_Failed `protobuf:"bytes,2,opt,name=failed,proto3,oneof" json:"failed,omitempty"`
}

func (*Result_Success_) isResult_Sum() {}
func (*Result_Failed_) isResult_Sum()  {}

func (m *Result) GetSum() isResult_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *Result) GetSuccess() *Result_Success {
	if x, ok := m.GetSum().(*Result_Success_); ok {
		return x.Success
	}
	return nil
}

func (m *Result) GetFailed() *Result_Failed {
	if x, ok := m.GetSum().(*Result_Failed_); ok {
		return x.Failed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Result) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Result_Success_)(nil),
		(*Result_Failed_)(nil),
	}
}

// Single is the signature data for a single signer
type Result_Success struct {
	// Value that has be signed by the profile
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// Signature that has been produced by signing the value
	Signature string `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Result_Success) Reset()         { *m = Result_Success{} }
func (m *Result_Success) String() string { return proto.CompactTextString(m) }
func (*Result_Success) ProtoMessage()    {}
func (*Result_Success) Descriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{3, 0}
}
func (m *Result_Success) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result_Success) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result_Success.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result_Success) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result_Success.Merge(m, src)
}
func (m *Result_Success) XXX_Size() int {
	return m.Size()
}
func (m *Result_Success) XXX_DiscardUnknown() {
	xxx_messageInfo_Result_Success.DiscardUnknown(m)
}

var xxx_messageInfo_Result_Success proto.InternalMessageInfo

func (m *Result_Success) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Result_Success) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// Multi is the signature data for a multisig public key
type Result_Failed struct {
	// Error that is associated with the failure
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *Result_Failed) Reset()         { *m = Result_Failed{} }
func (m *Result_Failed) String() string { return proto.CompactTextString(m) }
func (*Result_Failed) ProtoMessage()    {}
func (*Result_Failed) Descriptor() ([]byte, []int) {
	return fileDescriptor_0611fef640455089, []int{3, 1}
}
func (m *Result_Failed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result_Failed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result_Failed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result_Failed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result_Failed.Merge(m, src)
}
func (m *Result_Failed) XXX_Size() int {
	return m.Size()
}
func (m *Result_Failed) XXX_DiscardUnknown() {
	xxx_messageInfo_Result_Failed.DiscardUnknown(m)
}

var xxx_messageInfo_Result_Failed proto.InternalMessageInfo

func (m *Result_Failed) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterEnum("desmos.ibc.applications.profiles.v1.State", State_name, State_value)
	proto.RegisterType((*ApplicationData)(nil), "desmos.ibc.applications.profiles.v1.ApplicationData")
	proto.RegisterType((*VerificationData)(nil), "desmos.ibc.applications.profiles.v1.VerificationData")
	proto.RegisterType((*Connection)(nil), "desmos.ibc.applications.profiles.v1.Connection")
	proto.RegisterType((*Result)(nil), "desmos.ibc.applications.profiles.v1.Result")
	proto.RegisterType((*Result_Success)(nil), "desmos.ibc.applications.profiles.v1.Result.Success")
	proto.RegisterType((*Result_Failed)(nil), "desmos.ibc.applications.profiles.v1.Result.Failed")
}

func init() {
	proto.RegisterFile("desmos/ibc/applications/profiles/v1/models.proto", fileDescriptor_0611fef640455089)
}

var fileDescriptor_0611fef640455089 = []byte{
	// 708 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0xcb, 0x4e, 0xdb, 0x4a,
	0x18, 0xc7, 0x6d, 0x72, 0x01, 0x26, 0xe4, 0x10, 0x46, 0x2c, 0x22, 0xeb, 0xc8, 0x89, 0x72, 0xa4,
	0x23, 0x0e, 0x47, 0xb5, 0x9b, 0xd0, 0x76, 0x51, 0xa9, 0x6a, 0x73, 0x31, 0xc2, 0x12, 0x25, 0xd5,
	0xc4, 0x41, 0x82, 0x4d, 0x64, 0x3b, 0x93, 0x60, 0xc9, 0xce, 0x44, 0x9e, 0x71, 0x54, 0xde, 0xa0,
	0x42, 0xaa, 0xc4, 0x0b, 0xb0, 0xaa, 0xfa, 0x24, 0xdd, 0xb0, 0x64, 0xd9, 0x15, 0xad, 0xe0, 0x0d,
	0x78, 0x82, 0xca, 0x33, 0x76, 0x09, 0x2c, 0xaa, 0xb0, 0xfb, 0x6e, 0xff, 0xdf, 0x7c, 0x9e, 0xf9,
	0xcb, 0xe0, 0xf9, 0x10, 0xd3, 0x80, 0x50, 0xdd, 0x73, 0x5c, 0xdd, 0x9e, 0x4e, 0x7d, 0xcf, 0xb5,
	0x99, 0x47, 0x26, 0x54, 0x9f, 0x86, 0x64, 0xe4, 0xf9, 0x98, 0xea, 0xb3, 0xba, 0x1e, 0x90, 0x21,
	0xf6, 0xa9, 0x36, 0x0d, 0x09, 0x23, 0xf0, 0x1f, 0xa1, 0xd0, 0x3c, 0xc7, 0xd5, 0xe6, 0x15, 0x5a,
	0xaa, 0xd0, 0x66, 0x75, 0x65, 0x73, 0x4c, 0xc6, 0x84, 0xcf, 0xeb, 0x71, 0x24, 0xa4, 0x8a, 0xea,
	0x12, 0x7e, 0x98, 0x63, 0x53, 0xac, 0xcf, 0xea, 0x0e, 0x66, 0x76, 0x5d, 0x77, 0x89, 0x37, 0x49,
	0xfa, 0x95, 0x78, 0x0b, 0x97, 0x84, 0x58, 0x77, 0x7d, 0x0f, 0x4f, 0x58, 0x7c, 0xb6, 0x88, 0xd2,
	0x81, 0x31, 0x21, 0x63, 0x1f, 0xeb, 0x3c, 0x73, 0xa2, 0x91, 0xce, 0xbc, 0x00, 0x53, 0x66, 0x07,
	0x53, 0x31, 0x50, 0x6b, 0x82, 0xf5, 0xe6, 0xfd, 0x4e, 0x1d, 0x9b, 0xd9, 0x10, 0x82, 0xec, 0xc4,
	0x0e, 0x70, 0x59, 0xae, 0xca, 0x5b, 0xab, 0x88, 0xc7, 0x50, 0x01, 0x2b, 0x11, 0xc5, 0x21, 0xaf,
	0x2f, 0xf1, 0xfa, 0xef, 0xbc, 0x86, 0x41, 0xe9, 0x10, 0x87, 0xde, 0x68, 0x9e, 0xf1, 0x1f, 0xc8,
	0x07, 0x98, 0x9d, 0x90, 0xa1, 0xa0, 0xb4, 0x36, 0xee, 0xae, 0x2b, 0xc5, 0x53, 0x3b, 0xf0, 0x5f,
	0xd7, 0x44, 0xbd, 0x86, 0x92, 0x01, 0xf8, 0x2f, 0xc8, 0xcd, 0x6c, 0x3f, 0x4a, 0xb8, 0xad, 0xd2,
	0xdd, 0x75, 0x65, 0x4d, 0x4c, 0xf2, 0x72, 0x0d, 0x89, 0x76, 0xed, 0x6b, 0x06, 0x80, 0x36, 0x99,
	0x4c, 0xb0, 0x1b, 0x9f, 0x12, 0x6f, 0x19, 0x6f, 0x90, 0x6e, 0x19, 0xc7, 0xf0, 0x10, 0x14, 0xe6,
	0x2e, 0x98, 0x03, 0x0b, 0x8d, 0x17, 0xda, 0x02, 0xf7, 0xaf, 0x3d, 0xba, 0x04, 0x34, 0x0f, 0x82,
	0x47, 0x60, 0x6d, 0x36, 0xf7, 0x85, 0xe5, 0x0c, 0x07, 0xbf, 0x5c, 0x08, 0xfc, 0xf8, 0x6a, 0xd0,
	0x03, 0x14, 0x7c, 0x07, 0x72, 0x94, 0xd9, 0x0c, 0x97, 0xb3, 0x55, 0x79, 0xeb, 0xaf, 0xc6, 0xf6,
	0x42, 0xcc, 0x5e, 0xac, 0x40, 0x42, 0x08, 0xdb, 0x20, 0x1f, 0x62, 0x1a, 0xf9, 0xac, 0x9c, 0xe3,
	0x6b, 0xfd, 0xbf, 0x10, 0x02, 0x71, 0x09, 0x4a, 0xa4, 0xd0, 0x04, 0x45, 0x37, 0xc4, 0x7c, 0x6e,
	0x10, 0x5b, 0xa4, 0x9c, 0xe7, 0x2c, 0x45, 0x13, 0xfe, 0xd1, 0x52, 0xff, 0x68, 0x56, 0xea, 0x9f,
	0xd6, 0xca, 0xe5, 0x75, 0x45, 0x3a, 0xff, 0x51, 0x91, 0xd1, 0x5a, 0x2a, 0x8d, 0x9b, 0xb5, 0xcf,
	0x4b, 0x20, 0x2f, 0xe8, 0xb0, 0x0b, 0x96, 0x69, 0xe4, 0xba, 0x98, 0x52, 0xfe, 0x4c, 0x85, 0xc6,
	0xce, 0x13, 0x76, 0xd3, 0x7a, 0x42, 0xba, 0x27, 0xa1, 0x94, 0x02, 0xf7, 0x41, 0x7e, 0x64, 0x7b,
	0x3e, 0x1e, 0x26, 0x6f, 0xdb, 0x78, 0x0a, 0x6f, 0x97, 0x2b, 0xf7, 0x24, 0x94, 0x30, 0x94, 0x37,
	0x60, 0x39, 0x39, 0x03, 0x6e, 0xa6, 0x26, 0x14, 0x76, 0x12, 0x09, 0xfc, 0x1b, 0xac, 0x52, 0x6f,
	0x3c, 0xb1, 0x59, 0x14, 0xa6, 0xb6, 0xbf, 0x2f, 0x28, 0x2a, 0xc8, 0x0b, 0x64, 0xac, 0xc6, 0x61,
	0x48, 0x52, 0x33, 0x8a, 0xa4, 0x95, 0x03, 0x19, 0x1a, 0x05, 0xdb, 0xdf, 0x64, 0x90, 0xe3, 0x0f,
	0x06, 0x5f, 0x81, 0x4a, 0xcf, 0x6a, 0x5a, 0xc6, 0xa0, 0x7f, 0x60, 0x1e, 0x98, 0x96, 0xd9, 0xdc,
	0x37, 0x8f, 0x8d, 0xce, 0xa0, 0x7f, 0xd0, 0xfb, 0x60, 0xb4, 0xcd, 0x5d, 0xd3, 0xe8, 0x94, 0x24,
	0x65, 0xe3, 0xec, 0xa2, 0x5a, 0x7c, 0x30, 0x00, 0x55, 0x50, 0x14, 0xba, 0x9e, 0xd5, 0x44, 0x96,
	0xd1, 0x29, 0xc9, 0x4a, 0xe1, 0xec, 0xa2, 0xba, 0x9c, 0xa4, 0x50, 0x01, 0x05, 0xd1, 0x37, 0x10,
	0xea, 0xa2, 0xd2, 0x92, 0xb2, 0x7a, 0x76, 0x51, 0xcd, 0xf1, 0x64, 0x4e, 0xdb, 0x6f, 0xb7, 0x8d,
	0x5e, 0xaf, 0x94, 0x49, 0xb4, 0x22, 0x85, 0x55, 0xb0, 0x2e, 0xfa, 0x96, 0xf9, 0xde, 0xe8, 0x0c,
	0xba, 0x7d, 0xab, 0x94, 0x15, 0x13, 0x71, 0xa1, 0xdb, 0xb7, 0x94, 0xec, 0xa7, 0x2f, 0xaa, 0xd4,
	0x3a, 0xba, 0xbc, 0x51, 0xe5, 0xab, 0x1b, 0x55, 0xfe, 0x79, 0xa3, 0xca, 0xe7, 0xb7, 0xaa, 0x74,
	0x75, 0xab, 0x4a, 0xdf, 0x6f, 0x55, 0xe9, 0xf8, 0xed, 0xd8, 0x63, 0x27, 0x91, 0xa3, 0xb9, 0x24,
	0xd0, 0xc5, 0x6b, 0x3c, 0xf3, 0x6d, 0x87, 0x26, 0xb1, 0xfe, 0xf1, 0x0f, 0x7f, 0x4a, 0x76, 0x3a,
	0xc5, 0xd4, 0xc9, 0x73, 0x73, 0xed, 0xfc, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x87, 0xdd, 0x8a, 0x0f,
	0x5a, 0x05, 0x00, 0x00,
}

func (m *ApplicationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerificationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreationTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreationTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintModels(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x32
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Verification != nil {
		{
			size, err := m.Verification.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Application != nil {
		{
			size, err := m.Application.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintModels(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Result_Success_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result_Success_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Success != nil {
		{
			size, err := m.Success.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Result_Failed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result_Failed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Failed != nil {
		{
			size, err := m.Failed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Result_Success) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result_Success) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result_Success) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result_Failed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result_Failed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result_Failed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApplicationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *VerificationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Application != nil {
		l = m.Application.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Verification != nil {
		l = m.Verification.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreationTime)
	n += 1 + l + sovModels(uint64(l))
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *Result_Success_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success != nil {
		l = m.Success.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Result_Failed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failed != nil {
		l = m.Failed.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Result_Success) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Result_Failed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ApplicationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerificationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Application == nil {
				m.Application = &ApplicationData{}
			}
			if err := m.Application.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Verification == nil {
				m.Verification = &VerificationData{}
			}
			if err := m.Verification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Result_Success{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Result_Success_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Result_Failed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Result_Failed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result_Success) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Success: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Success: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result_Failed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
