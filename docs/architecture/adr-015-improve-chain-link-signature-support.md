# ADR 015: Improve chain links signature support

## Changelog

- May 19th, 2022: First draft

## Status

DRAFT Not Implemented

## Abstract

This ADR contains the specifications about new signature methods that should be supported when creating chain links in order to allow the linkage of external chains using commonly used third party wallets (e.g. MetaMask for Ethereum).    


## Context

Currently, when creating a chain link there are only two kind of signatures that are supported: Cosmos single signature (obtained using `sign(sha256(value))`) and Cosmos multi signatures. Although this allows to connect any Cosmos chain to a Desmos profile, it does not support external chains that might be using different signature algorithms and specifications. As an example, right now it's not possible to link Ethereum address using MetaMask as this uses the `personal_sign` algorithm which consists of the following: 

```
sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message)))
```

Considering each ecosystem usually has a third party wallet as a reference (let's think about Keplr for Cosmos, MetaMask for Ethereum and SolWallet for Solana), it's important that we support the signature specifications that such widely used wallets use. This will allow users to connect their addresses to their Desmos profile more safely without needing any DApp to request them their secret (aka mnemonic) phrase to generate a valid signature.       

## Decision

In order to support most signature specifications as possible, we will define a `Signature` interface that will be implemented into two major instances: 

- `CosmosSignature`, representing a signature that is generated by a Cosmos-compatible wallet (eg. Keplr)
- `EVMSignature`, representing a signature that is generated by an EVM-compatible wallet (eg. MetaMask)

### `Signature`

The `Signature` interface will represent a generic signature, and thus will have only a method that should be used to verify it: 

```go
// Signature represents a generic signature data
type Signature interface {
	// Verify allows to verify this signature using the given public key against the given plain text
	Verify(pubKey *any.Any, plainText string) error
}

```

### `CosmosSignature`

The `CosmosSignature` implementation of the `Signature` interface will be as follows: 

```protobuf
syntax = "proto3";

// CosmosSignature represents a signature generated using a Cosmos-compatible wallet 
message CosmosSignature {
  // Encoding of the signed value 
  ValueEncoding value_encoding = 1;
  
  // Data of the signature
  google.protobuf.Any signature_data = 2;
  
  // ValueEncoding contains the different kinds of value encoding that the signature can have
  enum ValueEncoding {
    // Unknown should never be used
    Unknown = 0;
    
    // TXLegacyAmino should be used when the signed value is an Amino transaction, containing the address inside its memo 
    TXLegacyAmino = 1;
    
    // TXDirect should be used when the signed value is a Protobuf transaction containing the address inside its memo
    TXDirect = 2;
    
    // Textual should be used when the signed value is the address itself
    Textual = 3;
  }
}

// CosmosSingleSignatureData contains the signature data of a single Cosmos-compatible signature
message CosmosSingleSignatureData {
  // Raw signature bytes
  bytes signature = 1;
}

// CosmosMultiSignatureData contains the signature data of a Cosmos-compatible multisig
message CosmosMultiSignatureData {
  // Bitarray specifies which keys within the multisig are signing
  cosmos.crypto.multisig.v1beta1.CompactBitArray bit_array = 1;

  // Signatures of the multi-signature
  repeated google.protobuf.Any signatures = 2;
}
```

### `EVMSignature`

The `EVMSignature` implementation of the `Signature` interface will be as follows:

```protobuf
syntax = "proto3";

// EVMSignature contains the data of a signature generated using an EVM-compatible wallet
message EVMSignature {
  // Method used when generating the signature
  Method signing_method = 1;
  
  // Raw signature bytes
  bytes signature = 2;
  
  enum Method {
    // Unknown should never be used
    Unknown = 0;
    
    // PersonalSign should be used when the value has been signed using the personal_sign signature method
    PersonalSign = 1;
  }
}
```

## Consequences

### Backwards Compatibility

The proposed solution is partially backward compatible, but a store migration is still required. Particularly, for each link:
- all `SingleSignatureData` instances should be converted to `CosmosSignature` containing a `CosmosSingleSignatureData`; 
- all `MultiSignatureData` instances should be converted to `CosmosSignature` containing a `CosmosMultiSignatureData`;

Also, the `Proof#Verify` method must be updated in order to not check for different signature types, but to simply rely on the `Signature#Verify` method instead.

### Positive

- Allows for a greater extensibility in the future 
- Makes it easier to verify a signature

### Negative

### Neutral

## Further Discussions

We should perform a search within the Solana ecosystem to understand what are the most used wallets, and what kind of signature specification they allow the user to use in order to sign arbitrary data. This will allow us to implement this kind of `Signature` as well. 

## Test Cases

- Make sure the current signatures are migrated properly to the new types

## References

- [MetaMask signing data](https://docs.metamask.io/guide/signing-data.html)
- [EIP-712](https://eips.ethereum.org/EIPS/eip-712)
- [How Solana transaction works](https://medium.com/@asmiller1989/solana-transactions-in-depth-1f7f7fe06ac2)