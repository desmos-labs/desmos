"use strict";(self.webpackChunkdesmos_docs=self.webpackChunkdesmos_docs||[]).push([[7181],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),g=i,m=d["".concat(l,".").concat(g)]||d[g]||c[g]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},56718:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});n(67294);var a=n(3905);function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const o={},s="ADR 015: Improve chain links signature support",l={unversionedId:"architecture/adr-015-improve-chain-link-signature-support",id:"architecture/adr-015-improve-chain-link-signature-support",title:"ADR 015: Improve chain links signature support",description:"Changelog",source:"@site/docs/architecture/adr-015-improve-chain-link-signature-support.md",sourceDirName:"architecture",slug:"/architecture/adr-015-improve-chain-link-signature-support",permalink:"/architecture/adr-015-improve-chain-link-signature-support",draft:!1,editUrl:"https://github.com/desmos-labs/desmos/tree/master/docs/docs/architecture/adr-015-improve-chain-link-signature-support.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ADR 014: Improve the permission system",permalink:"/architecture/adr-014-improve-permissions"},next:{title:"ADR 016: Reactions module",permalink:"/architecture/adr-016-reactions-module"}},u={},p=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"<code>Signature</code>",id:"signature",level:3},{value:"<code>SingleSignature</code>",id:"singlesignature",level:3},{value:"<code>CosmosMultiSignature</code>",id:"cosmosmultisignature",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"Test Cases",id:"test-cases",level:2},{value:"References",id:"references",level:2}],c={toc:p};function d(e){var{components:t}=e,n=r(e,["components"]);return(0,a.kt)("wrapper",i({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",i({},{id:"adr-015-improve-chain-links-signature-support"}),"ADR 015: Improve chain links signature support"),(0,a.kt)("h2",i({},{id:"changelog"}),"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"May 19th, 2022: First draft")),(0,a.kt)("h2",i({},{id:"status"}),"Status"),(0,a.kt)("p",null,"ACCEPTED Implemented"),(0,a.kt)("h2",i({},{id:"abstract"}),"Abstract"),(0,a.kt)("p",null,"This ADR contains the specifications about new signature methods that should be supported when creating chain links in order to allow the linkage of external chains using commonly used third party wallets (e.g. MetaMask for Ethereum).    "),(0,a.kt)("h2",i({},{id:"context"}),"Context"),(0,a.kt)("p",null,"Currently, when creating a chain link there are only two kind of signatures that are supported: Cosmos single signature (obtained using ",(0,a.kt)("inlineCode",{parentName:"p"},"sign(sha256(value))"),") and Cosmos multi signatures. Although this allows to connect any Cosmos chain to a Desmos profile, it does not support external chains that might be using different signature algorithms and specifications. As an example, right now it's not possible to link Ethereum address using MetaMask as this uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"personal_sign")," algorithm which consists of the following: "),(0,a.kt)("pre",null,(0,a.kt)("code",i({parentName:"pre"},{}),'sign(keccak256("\\x19Ethereum Signed Message:\\n" + len(message) + message)))\n')),(0,a.kt)("p",null,"Considering each ecosystem usually has a third party wallet as a reference (let's think about Keplr for Cosmos, MetaMask for Ethereum and SolWallet for Solana), it's important that we support the signature specifications that such widely used wallets use. This will allow users to connect their addresses to their Desmos profile more safely without needing any DApp to request them their secret (aka mnemonic) phrase to generate a valid signature.       "),(0,a.kt)("h2",i({},{id:"decision"}),"Decision"),(0,a.kt)("p",null,"In order to support most signature specifications as possible, we will define a ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature")," interface that will be implemented into two major instances: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SingleSignature"),", representing a signature that is generated by a single signer;"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CosmosMultiSignature"),", representing a signature that is generated by a Cosmos multi-signature wallet.")),(0,a.kt)("h3",i({},{id:"signature"}),(0,a.kt)("inlineCode",{parentName:"h3"},"Signature")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature")," interface will represent a generic signature, and thus will have only a method that should be used to validate it and another one used to verify it: "),(0,a.kt)("pre",null,(0,a.kt)("code",i({parentName:"pre"},{className:"language-go"}),"// Signature represents a generic signature data\ntype Signature interface {\n    // Validate checks the validity of the Signature\n    Validate(cdc codec.BinaryCodec, amino *codec.LegacyAmino, plainText []byte, owner string) error\n\n    // Verify allows to verify this signature using the given public key against the given plain text.\n    // If the signature is valid, it returns the public key instance used to verify it\n    Verify(cdc codec.BinaryCodec, pubKey *codectypes.Any, plainText []byte) (cryptotypes.PubKey, error)\n}\n\n")),(0,a.kt)("h3",i({},{id:"singlesignature"}),(0,a.kt)("inlineCode",{parentName:"h3"},"SingleSignature")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"SingleSignature")," implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature")," interface will be as follows: "),(0,a.kt)("pre",null,(0,a.kt)("code",i({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto3";\n\n// SingleSignature is the signature data for a single signer\nmessage SingleSignature {\n  option (gogoproto.goproto_getters) = false;\n  option (gogoproto.equal) = true;\n  option (cosmos_proto.implements_interface) = "CosmosSignature";\n\n  // ValueEncoding represents how the value has been encoded before being signed\n  SignatureValueEncoding value_encoding = 1\n  [ (gogoproto.moretags) = "yaml:\\"value_encoding\\"" ];\n\n  // Signature is the raw signature bytes\n  bytes signature = 2 [ (gogoproto.moretags) = "yaml:\\"signature\\"" ];\n}\n\n// SignatureValueEncoding tells how the value has been encoded before being\n// signed\nenum SignatureValueEncoding {\n  option (gogoproto.goproto_enum_prefix) = false;\n\n  // SIGNATURE_VALUE_ENCODING_UNSPECIFIED specifies an unknown signing mode and\n  // will be rejected\n  SIGNATURE_VALUE_ENCODING_UNSPECIFIED = 0;\n\n  // SIGNATURE_VALUE_ENCODING_RAW should be used when the value has been signed\n  // as a raw byte array\n  SIGNATURE_VALUE_ENCODING_RAW = 1;\n\n  // SIGNATURE_VALUE_ENCODING_COSMOS_DIRECT should be used when the signed value\n  // has been encoded as a Protobuf transaction containing the owner address\n  // inside its memo field\n  SIGNATURE_VALUE_ENCODING_COSMOS_DIRECT = 2;\n\n  // SIGNATURE_VALUE_ENCODING_COSMOS_AMINO should be used when the value has\n  // been encoded as an Amino transaction containing the owner address inside\n  // its memo field\n  SIGNATURE_VALUE_ENCODING_COSMOS_AMINO = 3;\n\n  // SIGNATURE_VALUE_ENCODING_EVM_PERSONAL_SIGN should be used when the value\n  // has been encoded following the EVM personal_sign specification\n  SIGNATURE_VALUE_ENCODING_EVM_PERSONAL_SIGN = 4;\n}\n')),(0,a.kt)("h3",i({},{id:"cosmosmultisignature"}),(0,a.kt)("inlineCode",{parentName:"h3"},"CosmosMultiSignature")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"CosmosMultiSignature")," implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature")," interface will be as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",i({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto3";\n\n// CosmosMultiSignature is the signature data for a multisig public key\nmessage CosmosMultiSignature {\n  option (gogoproto.goproto_getters) = false;\n  option (gogoproto.equal) = true;\n  option (cosmos_proto.implements_interface) = "CosmosSignature";\n\n  // Bitarray specifies which keys within the multisig are signing\n  cosmos.crypto.multisig.v1beta1.CompactBitArray bit_array = 1\n  [ (gogoproto.moretags) = "yaml:\\"bit_array\\"" ];\n\n  // Signatures is the signatures of the multi-signature\n  repeated google.protobuf.Any signatures = 2 [\n    (cosmos_proto.accepts_interface) = "CosmosSignature",\n    (gogoproto.moretags) = "yaml:\\"signatures\\""\n  ];\n}\n')),(0,a.kt)("h2",i({},{id:"consequences"}),"Consequences"),(0,a.kt)("h3",i({},{id:"backwards-compatibility"}),"Backwards Compatibility"),(0,a.kt)("p",null,"The proposed solution is partially backward compatible, but a store migration is still required. Particularly, for each link:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"all ",(0,a.kt)("inlineCode",{parentName:"li"},"SingleSignatureData")," instances should be converted to ",(0,a.kt)("inlineCode",{parentName:"li"},"SingleSignature"),"; "),(0,a.kt)("li",{parentName:"ul"},"all ",(0,a.kt)("inlineCode",{parentName:"li"},"MultiSignatureData")," instances should be converted to ",(0,a.kt)("inlineCode",{parentName:"li"},"CosmosMultiSignature"),";")),(0,a.kt)("p",null,"Also, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Proof#Verify")," method must be updated in order to not check for different signature types, but to simply rely on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature#Validate")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature#Verify")," methods instead."),(0,a.kt)("h3",i({},{id:"positive"}),"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Allows for a greater extensibility in the future "),(0,a.kt)("li",{parentName:"ul"},"Makes it easier to verify a signature")),(0,a.kt)("h3",i({},{id:"negative"}),"Negative"),(0,a.kt)("h3",i({},{id:"neutral"}),"Neutral"),(0,a.kt)("h2",i({},{id:"further-discussions"}),"Further Discussions"),(0,a.kt)("p",null,"We should perform a search within the Solana ecosystem to understand what are the most used wallets, and what kind of signature specification they allow the user to use in order to sign arbitrary data. This will allow us to implement this kind of ",(0,a.kt)("inlineCode",{parentName:"p"},"Signature")," as well. "),(0,a.kt)("h2",i({},{id:"test-cases"}),"Test Cases"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make sure the current signatures are migrated properly to the new types")),(0,a.kt)("h2",i({},{id:"references"}),"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",i({parentName:"li"},{href:"https://docs.metamask.io/guide/signing-data.html"}),"MetaMask signing data")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",i({parentName:"li"},{href:"https://eips.ethereum.org/EIPS/eip-712"}),"EIP-712")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",i({parentName:"li"},{href:"https://medium.com/@asmiller1989/solana-transactions-in-depth-1f7f7fe06ac2"}),"How Solana transaction works"))))}d.isMDXComponent=!0}}]);