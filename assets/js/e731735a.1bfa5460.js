"use strict";(self.webpackChunkdesmos_docs=self.webpackChunkdesmos_docs||[]).push([[12521],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var d=2;d<o;d++)s[d]=n[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48562:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});n(67294);var r=n(3905);function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},a.apply(this,arguments)}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const s={},i="ADR 007: Address generation of chain link proof",l={unversionedId:"architecture/adr-007-address-generation-of-chain-link-proof",id:"architecture/adr-007-address-generation-of-chain-link-proof",title:"ADR 007: Address generation of chain link proof",description:"Changelog",source:"@site/docs/architecture/adr-007-address-generation-of-chain-link-proof.md",sourceDirName:"architecture",slug:"/architecture/adr-007-address-generation-of-chain-link-proof",permalink:"/architecture/adr-007-address-generation-of-chain-link-proof",draft:!1,editUrl:"https://github.com/desmos-labs/desmos/tree/master/docs/docs/architecture/adr-007-address-generation-of-chain-link-proof.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ADR 006: Subspace module",permalink:"/architecture/adr-006-subspace-module"},next:{title:"ADR 008: Fees modules",permalink:"/architecture/adr-008-fee-module"}},d={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],p={toc:c};function u(e){var{components:t}=e,n=o(e,["components"]);return(0,r.kt)("wrapper",a({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",a({},{id:"adr-007-address-generation-of-chain-link-proof"}),"ADR 007: Address generation of chain link proof"),(0,r.kt)("h2",a({},{id:"changelog"}),"Changelog"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"January 20th, 2022: Initial draft;"),(0,r.kt)("li",{parentName:"ul"},"July 28th, 2022: First review;")),(0,r.kt)("h2",a({},{id:"status"}),"Status"),(0,r.kt)("p",null,"PROPOSED"),(0,r.kt)("h2",a({},{id:"abstract"}),"Abstract"),(0,r.kt)("p",null,"Currently, Desmos allows linking other chains accounts which addresses are formatted using either the ",(0,r.kt)("inlineCode",{parentName:"p"},"Bech32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Base58")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Hex")," encoding and generated using a single algorithm specific to the encoding itself. Since Desmos idea is to support as many chains as possible, we SHOULD split the address generation algorithm from the encoding algorithm so that more chains can be linked properly."),(0,r.kt)("h2",a({},{id:"context"}),"Context"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"x/profiles")," module gives users the possibility to link their profile to different external accounts.  However, each one of the supported address formats currently supports only one generation algorithm."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Bech32Address")," relies on the address generation algorithm specific of Cosmos-SDK chains:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"for single signature accounts: ",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",a({parentName:"pre"},{}),"ripemd160(sha256(32 bytes public key))[:20]\n"))),(0,r.kt)("li",{parentName:"ul"},"for multi-sig accounts: ",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",a({parentName:"pre"},{}),"sha256(aminoCdc.Marshal(multisig public key))[:20]\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Base58Address")," relies on the Solana algorithm:"),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{}),"(32 bytes public key)[:32]\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"HexAddress")," relies on the Ethereum algorithm:"),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{}),"keccak64(64 bytes public key)[12:]\n")),(0,r.kt)("p",null,"Due to the fact all the ",(0,r.kt)("inlineCode",{parentName:"p"},"AddressData")," implementations are highly coupled to a single address generation function, it is currently impossible to link an address that needs to be encoded using a supported encoding method but is generated using a different algorithm. This is the case of Elrond addresses which are encoded using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Bech32")," encoding algorithm, but are generated using an algorithm that is different from the Cosmos one."),(0,r.kt)("h2",a({},{id:"decision"}),"Decision"),(0,r.kt)("p",null,"In order to allow developers to integrate any kind of address, we will review how the current ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," structure is made. Instead of using an interface with multiple implementations based on the encoding algorithm, we will use a single structure that allows to specify both the encoding algorithm and the hashing algorithm(s) that should be used to get the proper address: "),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{className:"language-protobuf"}),'syntax = "proto3";\n\n// Address contains the data of an external address\nmessage Address {\n  // Encoded value of the address\n  string value = 1;\n  \n  // Algorithm that has been used in order to generate the address starting from the public key bytes\n  GenerationAlgorithm generation_algorithm = 2;\n  \n  // Algorithm that needs to be used to properly encode the address \n  google.proto.Any encoding_algorithm = 3 [ (cosmos_proto.accepts_interface) = "AddressEncoding" ];\n}\n\n// GenerationAlgorithm represents various address generation algorithms\nenum GenerationAlgorithm {\n  // GENERATION_ALGORITHM_UNKNOWN represents an unknown algorithm and will be discarded \n  GENERATION_ALGORITHM_UNKNOWN = 0;\n  \n  // GENERATION_ALGORITHM_COSMOS represents the Cosmos generation algorithm\n  GENERATION_ALGORITHM_COSMOS = 1;\n  \n  // GENERATION_ALGORITHM_EVM represents the EVM generation algorithm  \n  GENERATION_ALGORITHM_EVM = 2;\n  \n  // GENERATION_ALGORITHM_DO_NOTHING should be used when the public key bytes do not need to be modified  \n  GENERATION_ALGORITHM_DO_NOTHING = 3;\n}\n\n// Bech32Encoding represents the encoding algorithm based on the Bech32 format\nmessage Bech32Encoding {\n  option (cosmos_proto.implements_interface) = "AddressEncoding";\n  \n  // Prefix to be used\n  string prefix = 1; \n}\n\n// Base58Encoding represents the encoding algorithm based on the Base58 format\nmessage Base58Encoding {\n  option (cosmos_proto.implements_interface) = "AddressEncoding";\n\n  // (optional) Prefix to be used\n  string prefix = 1;\n}\n\n// HexEncoding represents the encoding algorithm based on the Hex format\nmessage HexEncoding {\n  option (cosmos_proto.implements_interface) = "AddressEncoding";\n  \n  // (optional) Prefix to be used\n  string prefix = 1;\n  \n  // (optional) Whether the address should be upper case or not (default: false)\n  bool uppercase = 2;\n}\n')),(0,r.kt)("p",null,"We will also define the following methods for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," structure: "),(0,r.kt)("pre",null,(0,r.kt)("code",a({parentName:"pre"},{className:"language-go"}),'// Validate validates the given public key against this address, to make sure they match\nfunc (a *Address) Validate(pubKey cryptotypes.PubKey) error {\n    addressBytes, err := hex.DecodeString(a.Value)\n    if err != nil {\n        return err\n    }\n    \n    // Generate the address bytes from the pub key\n    generatedBytes, err := generateAddressBytes(pubKey, a.GenerationAlgorithm)\n    if err != nil {\n        return err\n    }\n    \n    // Compare the bytes\n    if !bytes.Equals(addressBytes, generatedBytes) {\n        return fmt.Errrorf("address bytes do not match generated ones: expected %s but got %s", addressBytes, generatedBytes)   \n    }\n    \n    return nil\n}\n\n// generateAddressBytes generates the address bytes starting from the given public key \n// and using the provided generation algorithm\nfunc generateAddressBytes(pubKey cryptotypes.PubKey, generationAlgorithm GenerationAlgorithm) ([]byte, error) {\n    // ...\n}\n\n// GetValue returns the string value of the address, encoded as it should be\nfunc (a *Address) GetValue() string {\n    return a.Encoding.GetCachedValue().(AddressEncoding).Encode(a.Value)\n}\n')),(0,r.kt)("h2",a({},{id:"consequences"}),"Consequences"),(0,r.kt)("h3",a({},{id:"backwards-compatibility"}),"Backwards Compatibility"),(0,r.kt)("p",null,"Since this update will affect all the instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"AddressData")," by completely changing how it is defined, such changes are backwards incompatible. For this reason, we need to make sure we write a proper migration to update all the current ",(0,r.kt)("inlineCode",{parentName:"p"},"AddressData")," instances to the new ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," type. "),(0,r.kt)("h3",a({},{id:"positive"}),"Positive"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Easy to extend the address generation algorithm for ",(0,r.kt)("inlineCode",{parentName:"li"},"Address")," instances")),(0,r.kt)("h3",a({},{id:"negative"}),"Negative"),(0,r.kt)("h3",a({},{id:"neutral"}),"Neutral"),(0,r.kt)("h2",a({},{id:"references"}),"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",a({parentName:"li"},{href:"https://docs.cosmos.network/master/architecture/adr-028-public-key-addresses.html#legacy-public-key-addresses-don-t-change"}),"Cosmos address")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",a({parentName:"li"},{href:"https://ethereum.org/en/developers/docs/accounts/#account-creation"}),"Ethereum address")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",a({parentName:"li"},{href:"https://docs.solana.com/terminology#account"}),"Solana address")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",a({parentName:"li"},{href:"https://docs.elrond.com/technology/glossary/"}),"Elrond address")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",a({parentName:"li"},{href:"https://wiki.polkadot.network/docs/learn-accounts#address-format"}),"Polkadot address")),(0,r.kt)("li",{parentName:"ul"},"Issue ",(0,r.kt)("a",a({parentName:"li"},{href:"https://github.com/desmos-labs/desmos/issues/724"}),"#724"),".")))}u.isMDXComponent=!0}}]);