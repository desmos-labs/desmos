"use strict";(self.webpackChunkdesmos_docs=self.webpackChunkdesmos_docs||[]).push([[4953],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=i.createContext({}),c=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=c(e.components);return i.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(t),h=r,g=p["".concat(s,".").concat(h)]||p[h]||d[h]||a;return t?i.createElement(g,o(o({ref:n},u),{},{components:t})):i.createElement(g,o({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=p;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=t[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},52367:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});t(67294);var i=t(3905);function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},r.apply(this,arguments)}function a(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}const o={},l="ADR 001: Change chain link plain text encoding to hex",s={unversionedId:"architecture/adr-001-change-chain-links-plain-text-encoding-to-hex",id:"architecture/adr-001-change-chain-links-plain-text-encoding-to-hex",title:"ADR 001: Change chain link plain text encoding to hex",description:"Changelog",source:"@site/docs/architecture/adr-001-change-chain-links-plain-text-encoding-to-hex.md",sourceDirName:"architecture",slug:"/architecture/adr-001-change-chain-links-plain-text-encoding-to-hex",permalink:"/architecture/adr-001-change-chain-links-plain-text-encoding-to-hex",draft:!1,editUrl:"https://github.com/desmos-labs/desmos/tree/master/docs/docs/architecture/adr-001-change-chain-links-plain-text-encoding-to-hex.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ADR Creation Process",permalink:"/architecture/PROCESS"},next:{title:"ADR 002: Mutual DTags exchange",permalink:"/architecture/adr-002-mutual-dtags-exchange"}},c={},u=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Chain link implementation",id:"chain-link-implementation",level:3},{value:"Application link implementation",id:"application-link-implementation",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"Test Cases optional",id:"test-cases-optional",level:2},{value:"References",id:"references",level:2}],d={toc:u};function p(e){var{components:n}=e,t=a(e,["components"]);return(0,i.kt)("wrapper",r({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",r({},{id:"adr-001-change-chain-link-plain-text-encoding-to-hex"}),"ADR 001: Change chain link plain text encoding to hex"),(0,i.kt)("h2",r({},{id:"changelog"}),"Changelog"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"October 5th 2021: Initial draft;"),(0,i.kt)("li",{parentName:"ul"},"October 7th 2021: Moved from DRAFT to PROPOSED;"),(0,i.kt)("li",{parentName:"ul"},"October 10th 2021: First review;")),(0,i.kt)("h2",r({},{id:"status"}),"Status"),(0,i.kt)("p",null,"ACCEPTED Implemented"),(0,i.kt)("h2",r({},{id:"abstract"}),"Abstract"),(0,i.kt)("p",null,"Currently, when verifying an application link or a chain link we assume that their plain text values have been encoded using UTF-8.\nHowever, there is a major problem with the UTF-8 encoding: it does not support all bytes properly. For this reason, we SHOULD change\nthe encoding of the plain text from UTF-8 to HEX in order to avoid any possible encoding problem that would result in a signature\nthat it's impossible to verify correctly. "),(0,i.kt)("h2",r({},{id:"context"}),"Context"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"x/profiles")," module gives users the possibility to link their profile to some external account(s), either centralized applications\n(eg. GitHub, Reddit, Twitter) or other blockchains (eg. Cosmos, Solana, Polkadot). When linking a Desmos profile to any of these accounts,\nwe use a signature-based authentication process in order to make sure that the user controls such accounts. In both the applications\nand chains links, we currently expect the user to use the UTF-8 encoding when sending over the plain text used to create the signature.\nHowever, since the UTF-8 encoding is not able to correctly represent all bytes, there might be cases in which we end up with a signature\nthat it's impossible to verify. For example, this is what happens if the original plain text was encoded before being signed with another\nencoding such as UTF-16, Unicode, etc."),(0,i.kt)("h2",r({},{id:"decision"}),"Decision"),(0,i.kt)("p",null,"We propose to change the encoding of the plain text of both application link and chain link to hex."),(0,i.kt)("h3",r({},{id:"chain-link-implementation"}),"Chain link implementation"),(0,i.kt)("p",null,"When saving a ",(0,i.kt)("inlineCode",{parentName:"p"},"ChainLink"),", we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof")," object in order to verify the signature. To make sure it supports the HEX encoding\ninstead of the UTF-8 one, we need to change how the ",(0,i.kt)("inlineCode",{parentName:"p"},"Validate")," method checks for the validity of such proof:"),(0,i.kt)("pre",null,(0,i.kt)("code",r({parentName:"pre"},{className:"language-go"}),'// Validate checks the validity of the Proof\nfunc (p Proof) Validate() error {\n    \n    ...\n\n    _, err = hex.DecodeString(p.PlainText)\n    if err != nil {\n        return fmt.Errorf("invalid hex-encoded plain text")\n    }\n\n    return nil\n}\n')),(0,i.kt)("p",null,"Second, we need to change how the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof#Verify")," method verifies the signature provided in order to make sure that it deserializes\nthe plain text as an HEX value instead of an UTF-8 one:"),(0,i.kt)("pre",null,(0,i.kt)("code",r({parentName:"pre"},{className:"language-go"}),'// Verify verifies the signature using the given plain text and public key.\n// It returns an error if something is invalid.\nfunc (p Proof) Verify(unpacker codectypes.AnyUnpacker, address AddressData) error {\n    var pubkey cryptotypes.PubKey\n    err := unpacker.UnpackAny(p.PubKey, &pubkey)\n    if err != nil {\n        return fmt.Errorf("failed to unpack the public key")\n    }\n\n    value, err := hex.DecodeString(p.PlainText)\n    if err != nil {\n        return fmt.Errorf("invalid hex-encoded plain text")\n    }\n    \n    sig, err := hex.DecodeString(p.Signature)\n    if err != nil {\n        return fmt.Errorf("invalid hex-encoded signature")\n    }\n\n    if !pubkey.VerifySignature(value, sig) {\n        return fmt.Errorf("failed to verify the signature")\n    }\n\n    valid, err := address.VerifyPubKey(pubkey)\n    if err != nil {\n        return err\n    }\n\n    if !valid {\n        return fmt.Errorf("invalid address and public key combination provided")\n    }\n\n    return nil\n}\n')),(0,i.kt)("p",null,"Finally, we need to modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"generateChainLinkJSON")," function to return a HEX encoded plain text:"),(0,i.kt)("pre",null,(0,i.kt)("code",r({parentName:"pre"},{className:"language-go"}),"// generateChainLinkJSON returns build a new ChainLinkJSON instance using the provided mnemonic and chain configuration\nfunc generateChainLinkJSON(mnemonic string, chain chainlinktypes.Chain) (profilescliutils.ChainLinkJSON, error) {\n    \n    ...\n\n    sig, pubkey, err := keyBase.Sign(keyName, []byte(value)) \n    if err != nil {\n        return profilescliutils.ChainLinkJSON{}, err\n    }\n\n    return profilescliutils.NewChainLinkJSON(\n        profilestypes.NewBech32Address(addr, chain.Prefix),\n        profilestypes.NewProof(pubkey, hex.EncodeToString(sig), hex.EncodeToString([]byte(value))),\n        profilestypes.NewChainConfig(chain.Name),\n    ), nil\n}\n")),(0,i.kt)("h3",r({},{id:"application-link-implementation"}),"Application link implementation"),(0,i.kt)("p",null,"While dealing with application links, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Result_Success_")," type to identify a successfully verified link. In order to force\nthe plain text to be HEX encoded, we need to modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"Validate")," function to perform such check:"),(0,i.kt)("pre",null,(0,i.kt)("code",r({parentName:"pre"},{className:"language-go"}),'// Validate returns an error if the instance does not contain valid data\nfunc (r Result_Success_) Validate() error {\n    \n    ...\n\n    if _, err := hex.DecodeString(r.Value); err != nil {\n        return fmt.Errorf("invalid hex-encoded plain text")\n    }\n\n    return nil\n}\n')),(0,i.kt)("p",null,"Besides, we also need to change the function that is currently used by users to generate the signature using the Desmos CLI to\nmake sure it returns the plain text using the HEX encoding:"),(0,i.kt)("pre",null,(0,i.kt)("code",r({parentName:"pre"},{className:"language-go"}),'// GetSignCmd returns the command allowing to sign an arbitrary value for later verification\nfunc GetSignCmd() *cobra.Command {\n    cmd := &cobra.Command{\n        Use:   "sign [value]",\n        Short: "Allows to sign the given value using the private key associated to the address or key specified using the --from flag",\n        RunE: func(cmd *cobra.Command, args []string) error {\n            \n            ...\n\n            value := []byte(args[0])\n            bz, pubKey, err := txFactory.Keybase().Sign(key.GetName(), value)\n            if err != nil {\n                return err\n            }\n\n            // Build the signature data output\n            signatureData := SignatureData{\n                Address:   strings.ToLower(pubKey.Address().String()),\n                Signature: strings.ToLower(hex.EncodeToString(bz)),\n                PubKey:    strings.ToLower(hex.EncodeToString(pubKey.Bytes())),\n                Value:     hex.EncodeToString(value),\n            }\n\n            // Serialize the output as JSON and print it\n            bz, err = json.Marshal(&signatureData)\n            if err != nil {\n                return err\n            }\n\n            return clientCtx.PrintBytes(bz)\n        },\n    }\n\n    flags.AddTxFlagsToCmd(cmd)\n\n    return cmd\n}\n')),(0,i.kt)("h2",r({},{id:"consequences"}),"Consequences"),(0,i.kt)("h3",r({},{id:"backwards-compatibility"}),"Backwards Compatibility"),(0,i.kt)("p",null,"With this approach there SHOULD not be any problem with old chain and application links since since the signature was\nverified during the creation process and this ADR only targets the new links that will be created. However, in order to\nmake sure that clients can verify all the links at the same way, we SHOULD keep the on-chain data consistent using a migration script\nthat transforms all currently stored plain texts from being UTF-8 encoded strings into HEX encoded strings.\nAs a result, this feature is backwards compatible."),(0,i.kt)("h3",r({},{id:"positive"}),"Positive"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ensure the signing and verification process for chain and application links work properly with arbitrary bytes")),(0,i.kt)("h3",r({},{id:"negative"}),"Negative"),(0,i.kt)("p",null,"(none known)"),(0,i.kt)("h3",r({},{id:"neutral"}),"Neutral"),(0,i.kt)("p",null,"(none known)"),(0,i.kt)("h2",r({},{id:"further-discussions"}),"Further Discussions"),(0,i.kt)("h2",r({},{id:"test-cases-optional"}),"Test Cases ","[optional]"),(0,i.kt)("h2",r({},{id:"references"}),"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Issue ",(0,i.kt)("a",r({parentName:"li"},{href:"https://github.com/desmos-labs/desmos/issues/636"}),"#636")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",r({parentName:"li"},{href:"https://www.codeguru.com/cplusplus/the-basics-of-utf-8/"}),"The basics of UTF-8"))))}p.isMDXComponent=!0}}]);