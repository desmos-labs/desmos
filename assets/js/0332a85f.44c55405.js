"use strict";(self.webpackChunkdesmos_docs=self.webpackChunkdesmos_docs||[]).push([[46665],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(i,".").concat(m)]||p[m]||d[m]||s;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=p;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<s;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},14108:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>u});n(67294);var a=n(3905);function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const o={},l="ADR 008: Fees modules",i={unversionedId:"architecture/adr-008-fee-module",id:"architecture/adr-008-fee-module",title:"ADR 008: Fees modules",description:"Changelog",source:"@site/docs/architecture/adr-008-fee-module.md",sourceDirName:"architecture",slug:"/architecture/adr-008-fee-module",permalink:"/architecture/adr-008-fee-module",draft:!1,editUrl:"https://github.com/desmos-labs/desmos/tree/master/docs/docs/architecture/adr-008-fee-module.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ADR 007: Address generation of chain link proof",permalink:"/architecture/adr-007-address-generation-of-chain-link-proof"},next:{title:"ADR 009: Supply module",permalink:"/architecture/adr-009-supply-module"}},c={},u=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Types",id:"types",level:3},{value:"Min Fees",id:"min-fees",level:4},{value:"Params",id:"params",level:4},{value:"Ante Handler and Fee Decorator",id:"ante-handler-and-fee-decorator",level:4},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Test Cases",id:"test-cases",level:2},{value:"References",id:"references",level:2}],d={toc:u};function p(e){var{components:t}=e,n=s(e,["components"]);return(0,a.kt)("wrapper",r({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",r({},{id:"adr-008-fees-modules"}),"ADR 008: Fees modules"),(0,a.kt)("h2",r({},{id:"changelog"}),"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"March 2, 2022: Initial draft;"),(0,a.kt)("li",{parentName:"ul"},"March 8, 2022: First review;"),(0,a.kt)("li",{parentName:"ul"},"March 9, 2022: Second review;"),(0,a.kt)("li",{parentName:"ul"},"March 10, 2022: Third review.")),(0,a.kt)("h2",r({},{id:"status"}),"Status"),(0,a.kt)("p",null,"ACCEPTED Implemented"),(0,a.kt)("h2",r({},{id:"abstract"}),"Abstract"),(0,a.kt)("p",null,"This ADR defines the ",(0,a.kt)("inlineCode",{parentName:"p"},"x/fees")," module which allows setting custom min fees for each message type."),(0,a.kt)("h2",r({},{id:"context"}),"Context"),(0,a.kt)("p",null,"In order to better prevent any kind of spam (e.g. zero-gas attacks, garbage smart contracts implementations, etc.) it's useful\nto have a system that allows to set a minimum amount of fees that needs to be paid when sending specific messages that can be vectors of such spam attacks.\nThis system should allow changing dynamically such min fees amounts, so that the community can properly tweak them if necessary."),(0,a.kt)("h2",r({},{id:"decision"}),"Decision"),(0,a.kt)("p",null,"We will create a module named ",(0,a.kt)("inlineCode",{parentName:"p"},"fees")," that allows setting such min fee amounts of any kind of messages that our chain supports.\nThis will then make sure that when such messages are broadcast inside a transaction, the transaction signer\nis paying at least the minimum amount of fees for each message."),(0,a.kt)("h3",r({},{id:"types"}),"Types"),(0,a.kt)("h4",r({},{id:"min-fees"}),"Min Fees"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-go"}),"type MinFee struct {\n    // The message type for which this min fee amount is valid\n    messageType string\n\n    // The min amount of fees to be paid for each instance of this type of message\n    amount sdk.Coins\n}\n")),(0,a.kt)("h4",r({},{id:"params"}),"Params"),(0,a.kt)("p",null,"We will save each ",(0,a.kt)("inlineCode",{parentName:"p"},"MinFee")," instance as the module on-chain params in order to be able to later change them with governance proposals as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-go"}),"type Params struct {\n    MinFees []MinFee\n}\n")),(0,a.kt)("h4",r({},{id:"ante-handler-and-fee-decorator"}),"Ante Handler and Fee Decorator"),(0,a.kt)("p",null,"We need to set up a custom ",(0,a.kt)("a",r({parentName:"p"},{href:"https://github.com/cosmos/cosmos-sdk/blob/da36c46f3a3a8dec7eaa85b69e7fa154e9d64dce/types/handler.go#L8"}),"AnteHandler"),"\nin order to be able to manage custom fees.",(0,a.kt)("br",{parentName:"p"}),"\n","This one will look exactly like the default one except for the fact that it will have an extra decorator to handle\ncustom fees:"),(0,a.kt)("pre",null,(0,a.kt)("code",r({parentName:"pre"},{className:"language-go"}),"type MinFeeDecorator struct {\n    feesKeeper feeskeeper.Keeper\n}\n")),(0,a.kt)("p",null,"The custom ",(0,a.kt)("inlineCode",{parentName:"p"},"AnteHandler")," will iterate over all the transaction's messages and perform the following operations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Fetch all the min fees to be paid for such message from the ",(0,a.kt)("inlineCode",{parentName:"li"},"x/fees")," params (if no min fees are set, then ",(0,a.kt)("inlineCode",{parentName:"li"},"minFee = 0"),");"),(0,a.kt)("li",{parentName:"ul"},"Sum all the min fees together;")),(0,a.kt)("p",null,"After having calculated the total required min fees, it will check that fees are greater or equals to the min fees,\nand, if not, return an error."),(0,a.kt)("h2",r({},{id:"consequences"}),"Consequences"),(0,a.kt)("h3",r({},{id:"positive"}),"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Spam prevention of transaction containing specific messages")),(0,a.kt)("h3",r({},{id:"negative"}),"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Applying custom fees to messages requires to add an extra decorator to the ",(0,a.kt)("inlineCode",{parentName:"li"},"AnteHandler"),",\nwhich will need to perform stateful checks that can eventually slow down the node a bit. ")),(0,a.kt)("h2",r({},{id:"test-cases"}),"Test Cases"),(0,a.kt)("p",null,"We will need to add the following test cases:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a transaction not having enough fees is rejected;"),(0,a.kt)("li",{parentName:"ul"},"a transaction having enough fees is accepted;"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"AnteHandler")," benchmark tests to make sure it does not impact the transaction handling process too much.")),(0,a.kt)("h2",r({},{id:"references"}),"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",r({parentName:"li"},{href:"https://docs.cosmos.network/v0.44/modules/auth/03_antehandlers.html#antehandlers"}),"Ante Handlers"),";"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",r({parentName:"li"},{href:"https://github.com/desmos-labs/desmos/issues/230"}),"First issue about min fees"),".")))}p.isMDXComponent=!0}}]);