"use strict";(self.webpackChunkdesmos_docs=self.webpackChunkdesmos_docs||[]).push([[28200],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,g=m["".concat(s,".").concat(d)]||m[d]||p[d]||a;return n?i.createElement(g,o(o({ref:t},c),{},{components:n})):i.createElement(g,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var u=2;u<a;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},92035:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});n(67294);var i=n(3905);function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},r.apply(this,arguments)}function a(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const o={},l="ADR 006: Support multisig chain link",s={unversionedId:"architecture/adr-005-support-multisig-chain-link",id:"architecture/adr-005-support-multisig-chain-link",title:"ADR 006: Support multisig chain link",description:"Changelog",source:"@site/docs/architecture/adr-005-support-multisig-chain-link.md",sourceDirName:"architecture",slug:"/architecture/adr-005-support-multisig-chain-link",permalink:"/architecture/adr-005-support-multisig-chain-link",draft:!1,editUrl:"https://github.com/desmos-labs/desmos/tree/master/docs/docs/architecture/adr-005-support-multisig-chain-link.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ADR 004: Expiration of application links",permalink:"/architecture/adr-004-application-links-expiration"},next:{title:"ADR 006: Subspace module",permalink:"/architecture/adr-006-subspace-module"}},u={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Proof implementation",id:"proof-implementation",level:3},{value:"CLI implementation",id:"cli-implementation",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"Test Cases optional",id:"test-cases-optional",level:2},{value:"References",id:"references",level:2}],p={toc:c};function m(e){var{components:t}=e,n=a(e,["components"]);return(0,i.kt)("wrapper",r({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",r({},{id:"adr-006-support-multisig-chain-link"}),"ADR 006: Support multisig chain link"),(0,i.kt)("h2",r({},{id:"changelog"}),"Changelog"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"September 29th 2021: Initial draft"),(0,i.kt)("li",{parentName:"ul"},"October 21th, 2021: Proposed"),(0,i.kt)("li",{parentName:"ul"},"October 21th, 2021: First Review"),(0,i.kt)("li",{parentName:"ul"},"October 22th, 2021: Second Review"),(0,i.kt)("li",{parentName:"ul"},"November 15th, 2021: Third Review")),(0,i.kt)("h2",r({},{id:"status"}),"Status"),(0,i.kt)("p",null,"ACCEPTED Implemented"),(0,i.kt)("h2",r({},{id:"abstract"}),"Abstract"),(0,i.kt)("p",null,"Currently, it is not possible to create a chain link using a multisig account. Since many validators MIGHT use multisig accounts, we SHOULD change the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof")," type and its ",(0,i.kt)("inlineCode",{parentName:"p"},"Verify")," function in order to support this kind of account as well."),(0,i.kt)("h2",r({},{id:"context"}),"Context"),(0,i.kt)("p",null,"Currently, the ",(0,i.kt)("inlineCode",{parentName:"p"},"x/profiles")," module gives users the possibility to link their profile to different external accounts.\nIn particular, to link other blockchains accounts to a profile, we follow this process:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the user signs a message with their own private key;"),(0,i.kt)("li",{parentName:"ol"},"the signature and the signed value are placed inside a ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," object;"),(0,i.kt)("li",{parentName:"ol"},"Desmos verifies the ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," object to guarantee that the user really owns such account and thus it can be linked successfully to their Desmos profile.")),(0,i.kt)("p",null,"Currently, this process works properly for single-signature accounts, but it does not support multi-signature accounts. This is due to the fact that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof")," type only supports single-account's signatures, and its ",(0,i.kt)("inlineCode",{parentName:"p"},"Verify")," function is only able to verify such signature type."),(0,i.kt)("h2",r({},{id:"decision"}),"Decision"),(0,i.kt)("p",null,"We propose to change the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof#Signature")," field to be of type ",(0,i.kt)("a",r({parentName:"p"},{href:"https://github.com/cosmos/cosmos-sdk/blob/master/proto/cosmos/tx/signing/v1beta1/signing.proto#L57"}),(0,i.kt)("inlineCode",{parentName:"a"},"SignatureDescriptor_Data")),"."),(0,i.kt)("h3",r({},{id:"proof-implementation"}),"Proof implementation"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SignatureDescriptor_Data")," supports storing both single and multi-sig signatures. Moreover, the Cosmos SDK provides a ",(0,i.kt)("a",r({parentName:"p"},{href:"https://github.com/cosmos/cosmos-sdk/blob/master/types/tx/signing/signature.go#L65"}),"function")," to convert such type into the corresponding interface (",(0,i.kt)("a",r({parentName:"p"},{href:"https://github.com/cosmos/cosmos-sdk/blob/master/types/tx/signing/signature_data.go#L10"}),(0,i.kt)("inlineCode",{parentName:"a"},"SignatureData")),"), which is required from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Verify")," function in order to validate such signature. "),(0,i.kt)("p",null,"The verification process can be implemented as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If it's a ",(0,i.kt)("inlineCode",{parentName:"li"},"SingleSignatureData"),", make sure the account public key is a ",(0,i.kt)("inlineCode",{parentName:"li"},"cryptotypes.PubKey")," and then use the ",(0,i.kt)("inlineCode",{parentName:"li"},"VerifySignature")," method to verify the signature."),(0,i.kt)("li",{parentName:"ol"},"If it's a ",(0,i.kt)("inlineCode",{parentName:"li"},"MultiSignatureData"),", make sure the account public key is a ",(0,i.kt)("inlineCode",{parentName:"li"},"multisig.PubKey")," and then use the ",(0,i.kt)("inlineCode",{parentName:"li"},"VerifyMultisignature")," method to verify the signature.")),(0,i.kt)("h3",r({},{id:"cli-implementation"}),"CLI implementation"),(0,i.kt)("p",null,"We propose to use an interactive prompt to create a new chain-link JSON for both single signature and multi signature account. For the single signature account, the process will remain the same as before. For the multi signature account, we will add the new feature beyond the current ones."),(0,i.kt)("p",null,"To simplify things for multisig accounts, we propose to create a chain link JSON starting from a transaction signed with a multisig account. Inside the Cosmos SDK, multisig account transactions signing depends on the ",(0,i.kt)("inlineCode",{parentName:"p"},"tx sign")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tx multisign")," commands. To send a transaction to the node, the following process takes place: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the multisig account owners create a raw transaction file;"),(0,i.kt)("li",{parentName:"ol"},"the threshold number of signers sign it to using the ",(0,i.kt)("inlineCode",{parentName:"li"},"tx sign")," command;"),(0,i.kt)("li",{parentName:"ol"},"all individual signatures are gathered and used as input from the ",(0,i.kt)("inlineCode",{parentName:"li"},"tx multisign")," to generate the final signed transaction.")),(0,i.kt)("p",null,"The multisign file includes not only all public keys and threshold of the multisig account, but also the required number of signatures. Thanks to this, we can leverage all the information stored inside such file to create a proper chain link JSON starting from a multisigned transaction."),(0,i.kt)("p",null,"The whole process in code is presented below:"),(0,i.kt)("pre",null,(0,i.kt)("code",r({parentName:"pre"},{className:"language-go"}),'// getChainLinkJSONFromMultiSign generates the chain-link JSON from the multisign file and its raw transaction file\nfunc getChainLinkJSONFromMultiSign(\n    cmd *cobra.Command,\n    txFile string,\n    chainID string,\n    chain chainlinktypes.Chain,\n) (profilescliutils.ChainLinkJSON, error) {\n    clientCtx, err := client.GetClientTxContext(cmd)\n    if err != nil {\n        return profilescliutils.ChainLinkJSON{}, err\n    }\n\n    parsedTx, err := authclient.ReadTxFromFile(clientCtx, txFile)\n    if err != nil {\n        return profilescliutils.ChainLinkJSON{}, err\n    }\n\n    txCfg := clientCtx.TxConfig\n    txBuilder, err := txCfg.WrapTxBuilder(parsedTx)\n    if err != nil {\n        return profilescliutils.ChainLinkJSON{}, err\n    }\n\n    txFactory := tx.NewFactoryCLI(clientCtx, cmd.Flags())\n    if txFactory.SignMode() == signingtypes.SignMode_SIGN_MODE_UNSPECIFIED {\n        txFactory = txFactory.WithSignMode(signingtypes.SignMode_SIGN_MODE_LEGACY_AMINO_JSON)\n    }\n\n    sigs, err := txBuilder.GetTx().GetSignaturesV2()\n    if len(sigs) != 1 {\n        return profilescliutils.ChainLinkJSON{}, fmt.Errorf("invalid number of signatures")\n    }\n    multisigSig := sigs[0]\n\n    signingData := authSigning.SignerData{\n        ChainID:       chainID,\n        AccountNumber: txFactory.AccountNumber(),\n        Sequence:      txFactory.Sequence(),\n    }\n    // the bytes of plain text\n    value, err := txCfg.SignModeHandler().GetSignBytes(txFactory.SignMode(), signingData, txBuilder.GetTx())\n    if err != nil {\n        return profilescliutils.ChainLinkJSON{}, err\n    }\n\n    addr, _ := sdk.Bech32ifyAddressBytes(chain.Prefix, multisigSig.PubKey.Address().Bytes())\n    return profilescliutils.NewChainLinkJSON(\n        profilestypes.NewBech32Address(addr, chain.Prefix),\n        profilestypes.NewProof(multisigSig.PubKey, signingtypes.SignatureDataToProto(multisigSig.Data), hex.EncodeToString(value)),\n        profilestypes.NewChainConfig(chain.Name),\n    ), nil\n}\n')),(0,i.kt)("h2",r({},{id:"consequences"}),"Consequences"),(0,i.kt)("h3",r({},{id:"backwards-compatibility"}),"Backwards Compatibility"),(0,i.kt)("p",null,"Since we change the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof#Signature")," field from a hex-encoded string into a ",(0,i.kt)("inlineCode",{parentName:"p"},"SignatureDescriptor_Data"),", this feature is not backwards compatible. For this reason, it will be needed to migrate the old chain link signatures to ",(0,i.kt)("inlineCode",{parentName:"p"},"SignatureDescriptor_Data"),"."),(0,i.kt)("h3",r({},{id:"positive"}),"Positive"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Give the possibility to link a multisig account to a Desmos profile")),(0,i.kt)("h3",r({},{id:"negative"}),"Negative"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Raise the complexity to generate and verify the signature")),(0,i.kt)("h3",r({},{id:"neutral"}),"Neutral"),(0,i.kt)("p",null,"(none known)"),(0,i.kt)("h2",r({},{id:"further-discussions"}),"Further Discussions"),(0,i.kt)("h2",r({},{id:"test-cases-optional"}),"Test Cases ","[optional]"),(0,i.kt)("p",null,"The following tests cases MUST to be present:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Verify ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," including wrong format signature returns error"),(0,i.kt)("li",{parentName:"ul"},"Verify ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," including non-matched single signature and pubkey returns error"),(0,i.kt)("li",{parentName:"ul"},"Verify ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," including non-matched multi signatures and pubkeys returns error"),(0,i.kt)("li",{parentName:"ul"},"Verify ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," including proper single signature and pubkey returns no error"),(0,i.kt)("li",{parentName:"ul"},"Verify ",(0,i.kt)("inlineCode",{parentName:"li"},"Proof")," including proper multi signatures and pubkeys returns no error")),(0,i.kt)("h2",r({},{id:"references"}),"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Issue ",(0,i.kt)("a",r({parentName:"li"},{href:"https://github.com/desmos-labs/desmos/issues/633"}),"#633")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",r({parentName:"li"},{href:"https://github.com/cosmos/cosmos-sdk/blob/master/types/tx/signing/signature_data.go"}),"SignatureData")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",r({parentName:"li"},{href:"https://github.com/cosmos/cosmos-sdk/blob/master/types/tx/signing/signature.go"}),"Signature")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",r({parentName:"li"},{href:"https://github.com/cosmos/cosmos-sdk/blob/master/crypto/keys/multisig/multisig.go"}),"Multisig"))))}m.isMDXComponent=!0}}]);